
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Mesa
 * 
 */
export type Mesa = $Result.DefaultSelection<Prisma.$MesaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Comanda
 * 
 */
export type Comanda = $Result.DefaultSelection<Prisma.$ComandaPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model Produto
 * 
 */
export type Produto = $Result.DefaultSelection<Prisma.$ProdutoPayload>
/**
 * Model PedidoItem
 * 
 */
export type PedidoItem = $Result.DefaultSelection<Prisma.$PedidoItemPayload>
/**
 * Model OrdemProducao
 * 
 */
export type OrdemProducao = $Result.DefaultSelection<Prisma.$OrdemProducaoPayload>
/**
 * Model OrdemItem
 * 
 */
export type OrdemItem = $Result.DefaultSelection<Prisma.$OrdemItemPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>
/**
 * Model LogStatus
 * 
 */
export type LogStatus = $Result.DefaultSelection<Prisma.$LogStatusPayload>
/**
 * Model PrinterConfig
 * 
 */
export type PrinterConfig = $Result.DefaultSelection<Prisma.$PrinterConfigPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Mesas
 * const mesas = await prisma.mesa.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Mesas
   * const mesas = await prisma.mesa.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.mesa`: Exposes CRUD operations for the **Mesa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mesas
    * const mesas = await prisma.mesa.findMany()
    * ```
    */
  get mesa(): Prisma.MesaDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.comanda`: Exposes CRUD operations for the **Comanda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comandas
    * const comandas = await prisma.comanda.findMany()
    * ```
    */
  get comanda(): Prisma.ComandaDelegate<ExtArgs>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs>;

  /**
   * `prisma.produto`: Exposes CRUD operations for the **Produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produto.findMany()
    * ```
    */
  get produto(): Prisma.ProdutoDelegate<ExtArgs>;

  /**
   * `prisma.pedidoItem`: Exposes CRUD operations for the **PedidoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoItems
    * const pedidoItems = await prisma.pedidoItem.findMany()
    * ```
    */
  get pedidoItem(): Prisma.PedidoItemDelegate<ExtArgs>;

  /**
   * `prisma.ordemProducao`: Exposes CRUD operations for the **OrdemProducao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdemProducaos
    * const ordemProducaos = await prisma.ordemProducao.findMany()
    * ```
    */
  get ordemProducao(): Prisma.OrdemProducaoDelegate<ExtArgs>;

  /**
   * `prisma.ordemItem`: Exposes CRUD operations for the **OrdemItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdemItems
    * const ordemItems = await prisma.ordemItem.findMany()
    * ```
    */
  get ordemItem(): Prisma.OrdemItemDelegate<ExtArgs>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs>;

  /**
   * `prisma.logStatus`: Exposes CRUD operations for the **LogStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogStatuses
    * const logStatuses = await prisma.logStatus.findMany()
    * ```
    */
  get logStatus(): Prisma.LogStatusDelegate<ExtArgs>;

  /**
   * `prisma.printerConfig`: Exposes CRUD operations for the **PrinterConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrinterConfigs
    * const printerConfigs = await prisma.printerConfig.findMany()
    * ```
    */
  get printerConfig(): Prisma.PrinterConfigDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Mesa: 'Mesa',
    Usuario: 'Usuario',
    Comanda: 'Comanda',
    Pedido: 'Pedido',
    Categoria: 'Categoria',
    Produto: 'Produto',
    PedidoItem: 'PedidoItem',
    OrdemProducao: 'OrdemProducao',
    OrdemItem: 'OrdemItem',
    Pagamento: 'Pagamento',
    LogStatus: 'LogStatus',
    PrinterConfig: 'PrinterConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "mesa" | "usuario" | "comanda" | "pedido" | "categoria" | "produto" | "pedidoItem" | "ordemProducao" | "ordemItem" | "pagamento" | "logStatus" | "printerConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Mesa: {
        payload: Prisma.$MesaPayload<ExtArgs>
        fields: Prisma.MesaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MesaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MesaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          findFirst: {
            args: Prisma.MesaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MesaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          findMany: {
            args: Prisma.MesaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>[]
          }
          create: {
            args: Prisma.MesaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          createMany: {
            args: Prisma.MesaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MesaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>[]
          }
          delete: {
            args: Prisma.MesaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          update: {
            args: Prisma.MesaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          deleteMany: {
            args: Prisma.MesaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MesaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MesaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MesaPayload>
          }
          aggregate: {
            args: Prisma.MesaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMesa>
          }
          groupBy: {
            args: Prisma.MesaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MesaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MesaCountArgs<ExtArgs>
            result: $Utils.Optional<MesaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Comanda: {
        payload: Prisma.$ComandaPayload<ExtArgs>
        fields: Prisma.ComandaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComandaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComandaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          findFirst: {
            args: Prisma.ComandaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComandaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          findMany: {
            args: Prisma.ComandaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>[]
          }
          create: {
            args: Prisma.ComandaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          createMany: {
            args: Prisma.ComandaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComandaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>[]
          }
          delete: {
            args: Prisma.ComandaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          update: {
            args: Prisma.ComandaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          deleteMany: {
            args: Prisma.ComandaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComandaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComandaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComandaPayload>
          }
          aggregate: {
            args: Prisma.ComandaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComanda>
          }
          groupBy: {
            args: Prisma.ComandaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComandaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComandaCountArgs<ExtArgs>
            result: $Utils.Optional<ComandaCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      Produto: {
        payload: Prisma.$ProdutoPayload<ExtArgs>
        fields: Prisma.ProdutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findFirst: {
            args: Prisma.ProdutoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findMany: {
            args: Prisma.ProdutoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          create: {
            args: Prisma.ProdutoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          createMany: {
            args: Prisma.ProdutoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProdutoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          delete: {
            args: Prisma.ProdutoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          update: {
            args: Prisma.ProdutoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          deleteMany: {
            args: Prisma.ProdutoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProdutoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          aggregate: {
            args: Prisma.ProdutoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduto>
          }
          groupBy: {
            args: Prisma.ProdutoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutoCountArgs<ExtArgs>
            result: $Utils.Optional<ProdutoCountAggregateOutputType> | number
          }
        }
      }
      PedidoItem: {
        payload: Prisma.$PedidoItemPayload<ExtArgs>
        fields: Prisma.PedidoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findFirst: {
            args: Prisma.PedidoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findMany: {
            args: Prisma.PedidoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          create: {
            args: Prisma.PedidoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          createMany: {
            args: Prisma.PedidoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          delete: {
            args: Prisma.PedidoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          update: {
            args: Prisma.PedidoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          deleteMany: {
            args: Prisma.PedidoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          aggregate: {
            args: Prisma.PedidoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedidoItem>
          }
          groupBy: {
            args: Prisma.PedidoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoItemCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemCountAggregateOutputType> | number
          }
        }
      }
      OrdemProducao: {
        payload: Prisma.$OrdemProducaoPayload<ExtArgs>
        fields: Prisma.OrdemProducaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdemProducaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdemProducaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          findFirst: {
            args: Prisma.OrdemProducaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdemProducaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          findMany: {
            args: Prisma.OrdemProducaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>[]
          }
          create: {
            args: Prisma.OrdemProducaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          createMany: {
            args: Prisma.OrdemProducaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdemProducaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>[]
          }
          delete: {
            args: Prisma.OrdemProducaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          update: {
            args: Prisma.OrdemProducaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          deleteMany: {
            args: Prisma.OrdemProducaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdemProducaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdemProducaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemProducaoPayload>
          }
          aggregate: {
            args: Prisma.OrdemProducaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdemProducao>
          }
          groupBy: {
            args: Prisma.OrdemProducaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdemProducaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdemProducaoCountArgs<ExtArgs>
            result: $Utils.Optional<OrdemProducaoCountAggregateOutputType> | number
          }
        }
      }
      OrdemItem: {
        payload: Prisma.$OrdemItemPayload<ExtArgs>
        fields: Prisma.OrdemItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdemItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdemItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          findFirst: {
            args: Prisma.OrdemItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdemItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          findMany: {
            args: Prisma.OrdemItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>[]
          }
          create: {
            args: Prisma.OrdemItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          createMany: {
            args: Prisma.OrdemItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdemItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>[]
          }
          delete: {
            args: Prisma.OrdemItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          update: {
            args: Prisma.OrdemItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          deleteMany: {
            args: Prisma.OrdemItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdemItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdemItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemItemPayload>
          }
          aggregate: {
            args: Prisma.OrdemItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdemItem>
          }
          groupBy: {
            args: Prisma.OrdemItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdemItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdemItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrdemItemCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
      LogStatus: {
        payload: Prisma.$LogStatusPayload<ExtArgs>
        fields: Prisma.LogStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          findFirst: {
            args: Prisma.LogStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          findMany: {
            args: Prisma.LogStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>[]
          }
          create: {
            args: Prisma.LogStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          createMany: {
            args: Prisma.LogStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>[]
          }
          delete: {
            args: Prisma.LogStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          update: {
            args: Prisma.LogStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          deleteMany: {
            args: Prisma.LogStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogStatusPayload>
          }
          aggregate: {
            args: Prisma.LogStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogStatus>
          }
          groupBy: {
            args: Prisma.LogStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogStatusCountArgs<ExtArgs>
            result: $Utils.Optional<LogStatusCountAggregateOutputType> | number
          }
        }
      }
      PrinterConfig: {
        payload: Prisma.$PrinterConfigPayload<ExtArgs>
        fields: Prisma.PrinterConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrinterConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrinterConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          findFirst: {
            args: Prisma.PrinterConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrinterConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          findMany: {
            args: Prisma.PrinterConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>[]
          }
          create: {
            args: Prisma.PrinterConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          createMany: {
            args: Prisma.PrinterConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrinterConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>[]
          }
          delete: {
            args: Prisma.PrinterConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          update: {
            args: Prisma.PrinterConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          deleteMany: {
            args: Prisma.PrinterConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrinterConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrinterConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrinterConfigPayload>
          }
          aggregate: {
            args: Prisma.PrinterConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrinterConfig>
          }
          groupBy: {
            args: Prisma.PrinterConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrinterConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrinterConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PrinterConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MesaCountOutputType
   */

  export type MesaCountOutputType = {
    comandas: number
  }

  export type MesaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comandas?: boolean | MesaCountOutputTypeCountComandasArgs
  }

  // Custom InputTypes
  /**
   * MesaCountOutputType without action
   */
  export type MesaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MesaCountOutputType
     */
    select?: MesaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MesaCountOutputType without action
   */
  export type MesaCountOutputTypeCountComandasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComandaWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    pedidos: number
    comandas: number
    logs: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | UsuarioCountOutputTypeCountPedidosArgs
    comandas?: boolean | UsuarioCountOutputTypeCountComandasArgs
    logs?: boolean | UsuarioCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComandasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComandaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogStatusWhereInput
  }


  /**
   * Count Type ComandaCountOutputType
   */

  export type ComandaCountOutputType = {
    pedidos: number
    pagamentos: number
  }

  export type ComandaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | ComandaCountOutputTypeCountPedidosArgs
    pagamentos?: boolean | ComandaCountOutputTypeCountPagamentosArgs
  }

  // Custom InputTypes
  /**
   * ComandaCountOutputType without action
   */
  export type ComandaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComandaCountOutputType
     */
    select?: ComandaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComandaCountOutputType without action
   */
  export type ComandaCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }

  /**
   * ComandaCountOutputType without action
   */
  export type ComandaCountOutputTypeCountPagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }


  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    itens: number
    ordensProducao: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | PedidoCountOutputTypeCountItensArgs
    ordensProducao?: boolean | PedidoCountOutputTypeCountOrdensProducaoArgs
  }

  // Custom InputTypes
  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountOrdensProducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemProducaoWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    produtos: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtos?: boolean | CategoriaCountOutputTypeCountProdutosArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProdutosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
  }


  /**
   * Count Type ProdutoCountOutputType
   */

  export type ProdutoCountOutputType = {
    itens: number
  }

  export type ProdutoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | ProdutoCountOutputTypeCountItensArgs
  }

  // Custom InputTypes
  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdutoCountOutputType
     */
    select?: ProdutoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProdutoCountOutputType without action
   */
  export type ProdutoCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }


  /**
   * Count Type PedidoItemCountOutputType
   */

  export type PedidoItemCountOutputType = {
    ordemItens: number
  }

  export type PedidoItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordemItens?: boolean | PedidoItemCountOutputTypeCountOrdemItensArgs
  }

  // Custom InputTypes
  /**
   * PedidoItemCountOutputType without action
   */
  export type PedidoItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItemCountOutputType
     */
    select?: PedidoItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoItemCountOutputType without action
   */
  export type PedidoItemCountOutputTypeCountOrdemItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemItemWhereInput
  }


  /**
   * Count Type OrdemProducaoCountOutputType
   */

  export type OrdemProducaoCountOutputType = {
    itens: number
  }

  export type OrdemProducaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | OrdemProducaoCountOutputTypeCountItensArgs
  }

  // Custom InputTypes
  /**
   * OrdemProducaoCountOutputType without action
   */
  export type OrdemProducaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducaoCountOutputType
     */
    select?: OrdemProducaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdemProducaoCountOutputType without action
   */
  export type OrdemProducaoCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Mesa
   */

  export type AggregateMesa = {
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  export type MesaAvgAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type MesaSumAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type MesaMinAggregateOutputType = {
    id: number | null
    numero: number | null
    status: string | null
  }

  export type MesaMaxAggregateOutputType = {
    id: number | null
    numero: number | null
    status: string | null
  }

  export type MesaCountAggregateOutputType = {
    id: number
    numero: number
    status: number
    _all: number
  }


  export type MesaAvgAggregateInputType = {
    id?: true
    numero?: true
  }

  export type MesaSumAggregateInputType = {
    id?: true
    numero?: true
  }

  export type MesaMinAggregateInputType = {
    id?: true
    numero?: true
    status?: true
  }

  export type MesaMaxAggregateInputType = {
    id?: true
    numero?: true
    status?: true
  }

  export type MesaCountAggregateInputType = {
    id?: true
    numero?: true
    status?: true
    _all?: true
  }

  export type MesaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mesa to aggregate.
     */
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     */
    orderBy?: MesaOrderByWithRelationInput | MesaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mesas
    **/
    _count?: true | MesaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MesaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MesaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MesaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MesaMaxAggregateInputType
  }

  export type GetMesaAggregateType<T extends MesaAggregateArgs> = {
        [P in keyof T & keyof AggregateMesa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMesa[P]>
      : GetScalarType<T[P], AggregateMesa[P]>
  }




  export type MesaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MesaWhereInput
    orderBy?: MesaOrderByWithAggregationInput | MesaOrderByWithAggregationInput[]
    by: MesaScalarFieldEnum[] | MesaScalarFieldEnum
    having?: MesaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MesaCountAggregateInputType | true
    _avg?: MesaAvgAggregateInputType
    _sum?: MesaSumAggregateInputType
    _min?: MesaMinAggregateInputType
    _max?: MesaMaxAggregateInputType
  }

  export type MesaGroupByOutputType = {
    id: number
    numero: number
    status: string
    _count: MesaCountAggregateOutputType | null
    _avg: MesaAvgAggregateOutputType | null
    _sum: MesaSumAggregateOutputType | null
    _min: MesaMinAggregateOutputType | null
    _max: MesaMaxAggregateOutputType | null
  }

  type GetMesaGroupByPayload<T extends MesaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MesaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MesaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MesaGroupByOutputType[P]>
            : GetScalarType<T[P], MesaGroupByOutputType[P]>
        }
      >
    >


  export type MesaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    status?: boolean
    comandas?: boolean | Mesa$comandasArgs<ExtArgs>
    _count?: boolean | MesaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mesa"]>

  export type MesaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    status?: boolean
  }, ExtArgs["result"]["mesa"]>

  export type MesaSelectScalar = {
    id?: boolean
    numero?: boolean
    status?: boolean
  }

  export type MesaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comandas?: boolean | Mesa$comandasArgs<ExtArgs>
    _count?: boolean | MesaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MesaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MesaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mesa"
    objects: {
      comandas: Prisma.$ComandaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero: number
      status: string
    }, ExtArgs["result"]["mesa"]>
    composites: {}
  }

  type MesaGetPayload<S extends boolean | null | undefined | MesaDefaultArgs> = $Result.GetResult<Prisma.$MesaPayload, S>

  type MesaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MesaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MesaCountAggregateInputType | true
    }

  export interface MesaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mesa'], meta: { name: 'Mesa' } }
    /**
     * Find zero or one Mesa that matches the filter.
     * @param {MesaFindUniqueArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MesaFindUniqueArgs>(args: SelectSubset<T, MesaFindUniqueArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mesa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MesaFindUniqueOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MesaFindUniqueOrThrowArgs>(args: SelectSubset<T, MesaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mesa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MesaFindFirstArgs>(args?: SelectSubset<T, MesaFindFirstArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mesa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindFirstOrThrowArgs} args - Arguments to find a Mesa
     * @example
     * // Get one Mesa
     * const mesa = await prisma.mesa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MesaFindFirstOrThrowArgs>(args?: SelectSubset<T, MesaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mesas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mesas
     * const mesas = await prisma.mesa.findMany()
     * 
     * // Get first 10 Mesas
     * const mesas = await prisma.mesa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mesaWithIdOnly = await prisma.mesa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MesaFindManyArgs>(args?: SelectSubset<T, MesaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mesa.
     * @param {MesaCreateArgs} args - Arguments to create a Mesa.
     * @example
     * // Create one Mesa
     * const Mesa = await prisma.mesa.create({
     *   data: {
     *     // ... data to create a Mesa
     *   }
     * })
     * 
     */
    create<T extends MesaCreateArgs>(args: SelectSubset<T, MesaCreateArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mesas.
     * @param {MesaCreateManyArgs} args - Arguments to create many Mesas.
     * @example
     * // Create many Mesas
     * const mesa = await prisma.mesa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MesaCreateManyArgs>(args?: SelectSubset<T, MesaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mesas and returns the data saved in the database.
     * @param {MesaCreateManyAndReturnArgs} args - Arguments to create many Mesas.
     * @example
     * // Create many Mesas
     * const mesa = await prisma.mesa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mesas and only return the `id`
     * const mesaWithIdOnly = await prisma.mesa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MesaCreateManyAndReturnArgs>(args?: SelectSubset<T, MesaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mesa.
     * @param {MesaDeleteArgs} args - Arguments to delete one Mesa.
     * @example
     * // Delete one Mesa
     * const Mesa = await prisma.mesa.delete({
     *   where: {
     *     // ... filter to delete one Mesa
     *   }
     * })
     * 
     */
    delete<T extends MesaDeleteArgs>(args: SelectSubset<T, MesaDeleteArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mesa.
     * @param {MesaUpdateArgs} args - Arguments to update one Mesa.
     * @example
     * // Update one Mesa
     * const mesa = await prisma.mesa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MesaUpdateArgs>(args: SelectSubset<T, MesaUpdateArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mesas.
     * @param {MesaDeleteManyArgs} args - Arguments to filter Mesas to delete.
     * @example
     * // Delete a few Mesas
     * const { count } = await prisma.mesa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MesaDeleteManyArgs>(args?: SelectSubset<T, MesaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mesas
     * const mesa = await prisma.mesa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MesaUpdateManyArgs>(args: SelectSubset<T, MesaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mesa.
     * @param {MesaUpsertArgs} args - Arguments to update or create a Mesa.
     * @example
     * // Update or create a Mesa
     * const mesa = await prisma.mesa.upsert({
     *   create: {
     *     // ... data to create a Mesa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mesa we want to update
     *   }
     * })
     */
    upsert<T extends MesaUpsertArgs>(args: SelectSubset<T, MesaUpsertArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mesas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaCountArgs} args - Arguments to filter Mesas to count.
     * @example
     * // Count the number of Mesas
     * const count = await prisma.mesa.count({
     *   where: {
     *     // ... the filter for the Mesas we want to count
     *   }
     * })
    **/
    count<T extends MesaCountArgs>(
      args?: Subset<T, MesaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MesaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MesaAggregateArgs>(args: Subset<T, MesaAggregateArgs>): Prisma.PrismaPromise<GetMesaAggregateType<T>>

    /**
     * Group by Mesa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MesaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MesaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MesaGroupByArgs['orderBy'] }
        : { orderBy?: MesaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MesaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMesaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mesa model
   */
  readonly fields: MesaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mesa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MesaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comandas<T extends Mesa$comandasArgs<ExtArgs> = {}>(args?: Subset<T, Mesa$comandasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mesa model
   */ 
  interface MesaFieldRefs {
    readonly id: FieldRef<"Mesa", 'Int'>
    readonly numero: FieldRef<"Mesa", 'Int'>
    readonly status: FieldRef<"Mesa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mesa findUnique
   */
  export type MesaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter, which Mesa to fetch.
     */
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa findUniqueOrThrow
   */
  export type MesaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter, which Mesa to fetch.
     */
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa findFirst
   */
  export type MesaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter, which Mesa to fetch.
     */
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     */
    orderBy?: MesaOrderByWithRelationInput | MesaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mesas.
     */
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mesas.
     */
    distinct?: MesaScalarFieldEnum | MesaScalarFieldEnum[]
  }

  /**
   * Mesa findFirstOrThrow
   */
  export type MesaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter, which Mesa to fetch.
     */
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     */
    orderBy?: MesaOrderByWithRelationInput | MesaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mesas.
     */
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mesas.
     */
    distinct?: MesaScalarFieldEnum | MesaScalarFieldEnum[]
  }

  /**
   * Mesa findMany
   */
  export type MesaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter, which Mesas to fetch.
     */
    where?: MesaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mesas to fetch.
     */
    orderBy?: MesaOrderByWithRelationInput | MesaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mesas.
     */
    cursor?: MesaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mesas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mesas.
     */
    skip?: number
    distinct?: MesaScalarFieldEnum | MesaScalarFieldEnum[]
  }

  /**
   * Mesa create
   */
  export type MesaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * The data needed to create a Mesa.
     */
    data: XOR<MesaCreateInput, MesaUncheckedCreateInput>
  }

  /**
   * Mesa createMany
   */
  export type MesaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mesas.
     */
    data: MesaCreateManyInput | MesaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mesa createManyAndReturn
   */
  export type MesaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mesas.
     */
    data: MesaCreateManyInput | MesaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mesa update
   */
  export type MesaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * The data needed to update a Mesa.
     */
    data: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
    /**
     * Choose, which Mesa to update.
     */
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa updateMany
   */
  export type MesaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mesas.
     */
    data: XOR<MesaUpdateManyMutationInput, MesaUncheckedUpdateManyInput>
    /**
     * Filter which Mesas to update
     */
    where?: MesaWhereInput
  }

  /**
   * Mesa upsert
   */
  export type MesaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * The filter to search for the Mesa to update in case it exists.
     */
    where: MesaWhereUniqueInput
    /**
     * In case the Mesa found by the `where` argument doesn't exist, create a new Mesa with this data.
     */
    create: XOR<MesaCreateInput, MesaUncheckedCreateInput>
    /**
     * In case the Mesa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MesaUpdateInput, MesaUncheckedUpdateInput>
  }

  /**
   * Mesa delete
   */
  export type MesaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
    /**
     * Filter which Mesa to delete.
     */
    where: MesaWhereUniqueInput
  }

  /**
   * Mesa deleteMany
   */
  export type MesaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mesas to delete
     */
    where?: MesaWhereInput
  }

  /**
   * Mesa.comandas
   */
  export type Mesa$comandasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    where?: ComandaWhereInput
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    cursor?: ComandaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComandaScalarFieldEnum | ComandaScalarFieldEnum[]
  }

  /**
   * Mesa without action
   */
  export type MesaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesa
     */
    select?: MesaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MesaInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    login: string | null
    role: string | null
    senha: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    login: string | null
    role: string | null
    senha: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    login: number
    role: number
    senha: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    login?: true
    role?: true
    senha?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    login?: true
    role?: true
    senha?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    login?: true
    role?: true
    senha?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    login: string
    role: string
    senha: string
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    login?: boolean
    role?: boolean
    senha?: boolean
    pedidos?: boolean | Usuario$pedidosArgs<ExtArgs>
    comandas?: boolean | Usuario$comandasArgs<ExtArgs>
    logs?: boolean | Usuario$logsArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    login?: boolean
    role?: boolean
    senha?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    login?: boolean
    role?: boolean
    senha?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | Usuario$pedidosArgs<ExtArgs>
    comandas?: boolean | Usuario$comandasArgs<ExtArgs>
    logs?: boolean | Usuario$logsArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      comandas: Prisma.$ComandaPayload<ExtArgs>[]
      logs: Prisma.$LogStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      login: string
      role: string
      senha: string
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedidos<T extends Usuario$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    comandas<T extends Usuario$comandasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comandasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Usuario$logsArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly login: FieldRef<"Usuario", 'String'>
    readonly role: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.pedidos
   */
  export type Usuario$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Usuario.comandas
   */
  export type Usuario$comandasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    where?: ComandaWhereInput
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    cursor?: ComandaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComandaScalarFieldEnum | ComandaScalarFieldEnum[]
  }

  /**
   * Usuario.logs
   */
  export type Usuario$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    where?: LogStatusWhereInput
    orderBy?: LogStatusOrderByWithRelationInput | LogStatusOrderByWithRelationInput[]
    cursor?: LogStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogStatusScalarFieldEnum | LogStatusScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Comanda
   */

  export type AggregateComanda = {
    _count: ComandaCountAggregateOutputType | null
    _avg: ComandaAvgAggregateOutputType | null
    _sum: ComandaSumAggregateOutputType | null
    _min: ComandaMinAggregateOutputType | null
    _max: ComandaMaxAggregateOutputType | null
  }

  export type ComandaAvgAggregateOutputType = {
    id: number | null
    mesaId: number | null
    usuarioId: number | null
    total: number | null
  }

  export type ComandaSumAggregateOutputType = {
    id: number | null
    mesaId: number | null
    usuarioId: number | null
    total: number | null
  }

  export type ComandaMinAggregateOutputType = {
    id: number | null
    mesaId: number | null
    usuarioId: number | null
    status: string | null
    total: number | null
    abertaEm: Date | null
    fechadaEm: Date | null
  }

  export type ComandaMaxAggregateOutputType = {
    id: number | null
    mesaId: number | null
    usuarioId: number | null
    status: string | null
    total: number | null
    abertaEm: Date | null
    fechadaEm: Date | null
  }

  export type ComandaCountAggregateOutputType = {
    id: number
    mesaId: number
    usuarioId: number
    status: number
    total: number
    abertaEm: number
    fechadaEm: number
    _all: number
  }


  export type ComandaAvgAggregateInputType = {
    id?: true
    mesaId?: true
    usuarioId?: true
    total?: true
  }

  export type ComandaSumAggregateInputType = {
    id?: true
    mesaId?: true
    usuarioId?: true
    total?: true
  }

  export type ComandaMinAggregateInputType = {
    id?: true
    mesaId?: true
    usuarioId?: true
    status?: true
    total?: true
    abertaEm?: true
    fechadaEm?: true
  }

  export type ComandaMaxAggregateInputType = {
    id?: true
    mesaId?: true
    usuarioId?: true
    status?: true
    total?: true
    abertaEm?: true
    fechadaEm?: true
  }

  export type ComandaCountAggregateInputType = {
    id?: true
    mesaId?: true
    usuarioId?: true
    status?: true
    total?: true
    abertaEm?: true
    fechadaEm?: true
    _all?: true
  }

  export type ComandaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comanda to aggregate.
     */
    where?: ComandaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comandas to fetch.
     */
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComandaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comandas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comandas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comandas
    **/
    _count?: true | ComandaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComandaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComandaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComandaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComandaMaxAggregateInputType
  }

  export type GetComandaAggregateType<T extends ComandaAggregateArgs> = {
        [P in keyof T & keyof AggregateComanda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComanda[P]>
      : GetScalarType<T[P], AggregateComanda[P]>
  }




  export type ComandaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComandaWhereInput
    orderBy?: ComandaOrderByWithAggregationInput | ComandaOrderByWithAggregationInput[]
    by: ComandaScalarFieldEnum[] | ComandaScalarFieldEnum
    having?: ComandaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComandaCountAggregateInputType | true
    _avg?: ComandaAvgAggregateInputType
    _sum?: ComandaSumAggregateInputType
    _min?: ComandaMinAggregateInputType
    _max?: ComandaMaxAggregateInputType
  }

  export type ComandaGroupByOutputType = {
    id: number
    mesaId: number
    usuarioId: number | null
    status: string
    total: number
    abertaEm: Date
    fechadaEm: Date | null
    _count: ComandaCountAggregateOutputType | null
    _avg: ComandaAvgAggregateOutputType | null
    _sum: ComandaSumAggregateOutputType | null
    _min: ComandaMinAggregateOutputType | null
    _max: ComandaMaxAggregateOutputType | null
  }

  type GetComandaGroupByPayload<T extends ComandaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComandaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComandaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComandaGroupByOutputType[P]>
            : GetScalarType<T[P], ComandaGroupByOutputType[P]>
        }
      >
    >


  export type ComandaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mesaId?: boolean
    usuarioId?: boolean
    status?: boolean
    total?: boolean
    abertaEm?: boolean
    fechadaEm?: boolean
    mesa?: boolean | MesaDefaultArgs<ExtArgs>
    usuario?: boolean | Comanda$usuarioArgs<ExtArgs>
    pedidos?: boolean | Comanda$pedidosArgs<ExtArgs>
    pagamentos?: boolean | Comanda$pagamentosArgs<ExtArgs>
    _count?: boolean | ComandaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comanda"]>

  export type ComandaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mesaId?: boolean
    usuarioId?: boolean
    status?: boolean
    total?: boolean
    abertaEm?: boolean
    fechadaEm?: boolean
    mesa?: boolean | MesaDefaultArgs<ExtArgs>
    usuario?: boolean | Comanda$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["comanda"]>

  export type ComandaSelectScalar = {
    id?: boolean
    mesaId?: boolean
    usuarioId?: boolean
    status?: boolean
    total?: boolean
    abertaEm?: boolean
    fechadaEm?: boolean
  }

  export type ComandaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mesa?: boolean | MesaDefaultArgs<ExtArgs>
    usuario?: boolean | Comanda$usuarioArgs<ExtArgs>
    pedidos?: boolean | Comanda$pedidosArgs<ExtArgs>
    pagamentos?: boolean | Comanda$pagamentosArgs<ExtArgs>
    _count?: boolean | ComandaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComandaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mesa?: boolean | MesaDefaultArgs<ExtArgs>
    usuario?: boolean | Comanda$usuarioArgs<ExtArgs>
  }

  export type $ComandaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comanda"
    objects: {
      mesa: Prisma.$MesaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      pagamentos: Prisma.$PagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mesaId: number
      usuarioId: number | null
      status: string
      total: number
      abertaEm: Date
      fechadaEm: Date | null
    }, ExtArgs["result"]["comanda"]>
    composites: {}
  }

  type ComandaGetPayload<S extends boolean | null | undefined | ComandaDefaultArgs> = $Result.GetResult<Prisma.$ComandaPayload, S>

  type ComandaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComandaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComandaCountAggregateInputType | true
    }

  export interface ComandaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comanda'], meta: { name: 'Comanda' } }
    /**
     * Find zero or one Comanda that matches the filter.
     * @param {ComandaFindUniqueArgs} args - Arguments to find a Comanda
     * @example
     * // Get one Comanda
     * const comanda = await prisma.comanda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComandaFindUniqueArgs>(args: SelectSubset<T, ComandaFindUniqueArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comanda that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComandaFindUniqueOrThrowArgs} args - Arguments to find a Comanda
     * @example
     * // Get one Comanda
     * const comanda = await prisma.comanda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComandaFindUniqueOrThrowArgs>(args: SelectSubset<T, ComandaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comanda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaFindFirstArgs} args - Arguments to find a Comanda
     * @example
     * // Get one Comanda
     * const comanda = await prisma.comanda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComandaFindFirstArgs>(args?: SelectSubset<T, ComandaFindFirstArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comanda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaFindFirstOrThrowArgs} args - Arguments to find a Comanda
     * @example
     * // Get one Comanda
     * const comanda = await prisma.comanda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComandaFindFirstOrThrowArgs>(args?: SelectSubset<T, ComandaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comandas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comandas
     * const comandas = await prisma.comanda.findMany()
     * 
     * // Get first 10 Comandas
     * const comandas = await prisma.comanda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comandaWithIdOnly = await prisma.comanda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComandaFindManyArgs>(args?: SelectSubset<T, ComandaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comanda.
     * @param {ComandaCreateArgs} args - Arguments to create a Comanda.
     * @example
     * // Create one Comanda
     * const Comanda = await prisma.comanda.create({
     *   data: {
     *     // ... data to create a Comanda
     *   }
     * })
     * 
     */
    create<T extends ComandaCreateArgs>(args: SelectSubset<T, ComandaCreateArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comandas.
     * @param {ComandaCreateManyArgs} args - Arguments to create many Comandas.
     * @example
     * // Create many Comandas
     * const comanda = await prisma.comanda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComandaCreateManyArgs>(args?: SelectSubset<T, ComandaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comandas and returns the data saved in the database.
     * @param {ComandaCreateManyAndReturnArgs} args - Arguments to create many Comandas.
     * @example
     * // Create many Comandas
     * const comanda = await prisma.comanda.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comandas and only return the `id`
     * const comandaWithIdOnly = await prisma.comanda.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComandaCreateManyAndReturnArgs>(args?: SelectSubset<T, ComandaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comanda.
     * @param {ComandaDeleteArgs} args - Arguments to delete one Comanda.
     * @example
     * // Delete one Comanda
     * const Comanda = await prisma.comanda.delete({
     *   where: {
     *     // ... filter to delete one Comanda
     *   }
     * })
     * 
     */
    delete<T extends ComandaDeleteArgs>(args: SelectSubset<T, ComandaDeleteArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comanda.
     * @param {ComandaUpdateArgs} args - Arguments to update one Comanda.
     * @example
     * // Update one Comanda
     * const comanda = await prisma.comanda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComandaUpdateArgs>(args: SelectSubset<T, ComandaUpdateArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comandas.
     * @param {ComandaDeleteManyArgs} args - Arguments to filter Comandas to delete.
     * @example
     * // Delete a few Comandas
     * const { count } = await prisma.comanda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComandaDeleteManyArgs>(args?: SelectSubset<T, ComandaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comandas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comandas
     * const comanda = await prisma.comanda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComandaUpdateManyArgs>(args: SelectSubset<T, ComandaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comanda.
     * @param {ComandaUpsertArgs} args - Arguments to update or create a Comanda.
     * @example
     * // Update or create a Comanda
     * const comanda = await prisma.comanda.upsert({
     *   create: {
     *     // ... data to create a Comanda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comanda we want to update
     *   }
     * })
     */
    upsert<T extends ComandaUpsertArgs>(args: SelectSubset<T, ComandaUpsertArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comandas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaCountArgs} args - Arguments to filter Comandas to count.
     * @example
     * // Count the number of Comandas
     * const count = await prisma.comanda.count({
     *   where: {
     *     // ... the filter for the Comandas we want to count
     *   }
     * })
    **/
    count<T extends ComandaCountArgs>(
      args?: Subset<T, ComandaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComandaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comanda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComandaAggregateArgs>(args: Subset<T, ComandaAggregateArgs>): Prisma.PrismaPromise<GetComandaAggregateType<T>>

    /**
     * Group by Comanda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComandaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComandaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComandaGroupByArgs['orderBy'] }
        : { orderBy?: ComandaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComandaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComandaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comanda model
   */
  readonly fields: ComandaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comanda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComandaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mesa<T extends MesaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MesaDefaultArgs<ExtArgs>>): Prisma__MesaClient<$Result.GetResult<Prisma.$MesaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends Comanda$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Comanda$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pedidos<T extends Comanda$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Comanda$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    pagamentos<T extends Comanda$pagamentosArgs<ExtArgs> = {}>(args?: Subset<T, Comanda$pagamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comanda model
   */ 
  interface ComandaFieldRefs {
    readonly id: FieldRef<"Comanda", 'Int'>
    readonly mesaId: FieldRef<"Comanda", 'Int'>
    readonly usuarioId: FieldRef<"Comanda", 'Int'>
    readonly status: FieldRef<"Comanda", 'String'>
    readonly total: FieldRef<"Comanda", 'Float'>
    readonly abertaEm: FieldRef<"Comanda", 'DateTime'>
    readonly fechadaEm: FieldRef<"Comanda", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comanda findUnique
   */
  export type ComandaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter, which Comanda to fetch.
     */
    where: ComandaWhereUniqueInput
  }

  /**
   * Comanda findUniqueOrThrow
   */
  export type ComandaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter, which Comanda to fetch.
     */
    where: ComandaWhereUniqueInput
  }

  /**
   * Comanda findFirst
   */
  export type ComandaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter, which Comanda to fetch.
     */
    where?: ComandaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comandas to fetch.
     */
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comandas.
     */
    cursor?: ComandaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comandas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comandas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comandas.
     */
    distinct?: ComandaScalarFieldEnum | ComandaScalarFieldEnum[]
  }

  /**
   * Comanda findFirstOrThrow
   */
  export type ComandaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter, which Comanda to fetch.
     */
    where?: ComandaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comandas to fetch.
     */
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comandas.
     */
    cursor?: ComandaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comandas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comandas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comandas.
     */
    distinct?: ComandaScalarFieldEnum | ComandaScalarFieldEnum[]
  }

  /**
   * Comanda findMany
   */
  export type ComandaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter, which Comandas to fetch.
     */
    where?: ComandaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comandas to fetch.
     */
    orderBy?: ComandaOrderByWithRelationInput | ComandaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comandas.
     */
    cursor?: ComandaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comandas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comandas.
     */
    skip?: number
    distinct?: ComandaScalarFieldEnum | ComandaScalarFieldEnum[]
  }

  /**
   * Comanda create
   */
  export type ComandaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * The data needed to create a Comanda.
     */
    data: XOR<ComandaCreateInput, ComandaUncheckedCreateInput>
  }

  /**
   * Comanda createMany
   */
  export type ComandaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comandas.
     */
    data: ComandaCreateManyInput | ComandaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comanda createManyAndReturn
   */
  export type ComandaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comandas.
     */
    data: ComandaCreateManyInput | ComandaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comanda update
   */
  export type ComandaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * The data needed to update a Comanda.
     */
    data: XOR<ComandaUpdateInput, ComandaUncheckedUpdateInput>
    /**
     * Choose, which Comanda to update.
     */
    where: ComandaWhereUniqueInput
  }

  /**
   * Comanda updateMany
   */
  export type ComandaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comandas.
     */
    data: XOR<ComandaUpdateManyMutationInput, ComandaUncheckedUpdateManyInput>
    /**
     * Filter which Comandas to update
     */
    where?: ComandaWhereInput
  }

  /**
   * Comanda upsert
   */
  export type ComandaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * The filter to search for the Comanda to update in case it exists.
     */
    where: ComandaWhereUniqueInput
    /**
     * In case the Comanda found by the `where` argument doesn't exist, create a new Comanda with this data.
     */
    create: XOR<ComandaCreateInput, ComandaUncheckedCreateInput>
    /**
     * In case the Comanda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComandaUpdateInput, ComandaUncheckedUpdateInput>
  }

  /**
   * Comanda delete
   */
  export type ComandaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
    /**
     * Filter which Comanda to delete.
     */
    where: ComandaWhereUniqueInput
  }

  /**
   * Comanda deleteMany
   */
  export type ComandaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comandas to delete
     */
    where?: ComandaWhereInput
  }

  /**
   * Comanda.usuario
   */
  export type Comanda$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Comanda.pedidos
   */
  export type Comanda$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Comanda.pagamentos
   */
  export type Comanda$pagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Comanda without action
   */
  export type ComandaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comanda
     */
    select?: ComandaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComandaInclude<ExtArgs> | null
  }


  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    comandaId: number | null
    garcomId: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    comandaId: number | null
    garcomId: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    comandaId: number | null
    garcomId: number | null
    status: string | null
    criadoEm: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    comandaId: number | null
    garcomId: number | null
    status: string | null
    criadoEm: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    comandaId: number
    garcomId: number
    status: number
    criadoEm: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    comandaId?: true
    garcomId?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    comandaId?: true
    garcomId?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    comandaId?: true
    garcomId?: true
    status?: true
    criadoEm?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    comandaId?: true
    garcomId?: true
    status?: true
    criadoEm?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    comandaId?: true
    garcomId?: true
    status?: true
    criadoEm?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id: number
    comandaId: number
    garcomId: number | null
    status: string
    criadoEm: Date
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comandaId?: boolean
    garcomId?: boolean
    status?: boolean
    criadoEm?: boolean
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
    garcom?: boolean | Pedido$garcomArgs<ExtArgs>
    itens?: boolean | Pedido$itensArgs<ExtArgs>
    ordensProducao?: boolean | Pedido$ordensProducaoArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comandaId?: boolean
    garcomId?: boolean
    status?: boolean
    criadoEm?: boolean
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
    garcom?: boolean | Pedido$garcomArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    id?: boolean
    comandaId?: boolean
    garcomId?: boolean
    status?: boolean
    criadoEm?: boolean
  }

  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
    garcom?: boolean | Pedido$garcomArgs<ExtArgs>
    itens?: boolean | Pedido$itensArgs<ExtArgs>
    ordensProducao?: boolean | Pedido$ordensProducaoArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PedidoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
    garcom?: boolean | Pedido$garcomArgs<ExtArgs>
  }

  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      comanda: Prisma.$ComandaPayload<ExtArgs>
      garcom: Prisma.$UsuarioPayload<ExtArgs> | null
      itens: Prisma.$PedidoItemPayload<ExtArgs>[]
      ordensProducao: Prisma.$OrdemProducaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      comandaId: number
      garcomId: number | null
      status: string
      criadoEm: Date
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }

  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoFindUniqueArgs>(args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pedido that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoFindFirstArgs>(args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoFindManyArgs>(args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
     */
    create<T extends PedidoCreateArgs>(args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pedidos.
     * @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoCreateManyArgs>(args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pedidos and returns the data saved in the database.
     * @param {PedidoCreateManyAndReturnArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pedidos and only return the `id`
     * const pedidoWithIdOnly = await prisma.pedido.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
     */
    delete<T extends PedidoDeleteArgs>(args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoUpdateArgs>(args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoDeleteManyArgs>(args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoUpdateManyArgs>(args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
     */
    upsert<T extends PedidoUpsertArgs>(args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comanda<T extends ComandaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComandaDefaultArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    garcom<T extends Pedido$garcomArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$garcomArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    itens<T extends Pedido$itensArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany"> | Null>
    ordensProducao<T extends Pedido$ordensProducaoArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$ordensProducaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pedido model
   */ 
  interface PedidoFieldRefs {
    readonly id: FieldRef<"Pedido", 'Int'>
    readonly comandaId: FieldRef<"Pedido", 'Int'>
    readonly garcomId: FieldRef<"Pedido", 'Int'>
    readonly status: FieldRef<"Pedido", 'String'>
    readonly criadoEm: FieldRef<"Pedido", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }

  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pedido createManyAndReturn
   */
  export type PedidoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }

  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }

  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }

  /**
   * Pedido.garcom
   */
  export type Pedido$garcomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Pedido.itens
   */
  export type Pedido$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Pedido.ordensProducao
   */
  export type Pedido$ordensProducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    where?: OrdemProducaoWhereInput
    orderBy?: OrdemProducaoOrderByWithRelationInput | OrdemProducaoOrderByWithRelationInput[]
    cursor?: OrdemProducaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdemProducaoScalarFieldEnum | OrdemProducaoScalarFieldEnum[]
  }

  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
  }


  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    setor: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    setor: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nome: number
    setor: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nome?: true
    setor?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nome?: true
    setor?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nome?: true
    setor?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nome: string
    setor: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    setor?: boolean
    produtos?: boolean | Categoria$produtosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    setor?: boolean
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectScalar = {
    id?: boolean
    nome?: boolean
    setor?: boolean
  }

  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produtos?: boolean | Categoria$produtosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      produtos: Prisma.$ProdutoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      setor: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriaFindManyArgs>(args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends CategoriaCreateArgs>(args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCreateManyArgs>(args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {CategoriaCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id`
     * const categoriaWithIdOnly = await prisma.categoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends CategoriaDeleteArgs>(args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaUpdateArgs>(args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaUpdateManyArgs>(args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produtos<T extends Categoria$produtosArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$produtosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria model
   */ 
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nome: FieldRef<"Categoria", 'String'>
    readonly setor: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria createManyAndReturn
   */
  export type CategoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
  }

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
  }

  /**
   * Categoria.produtos
   */
  export type Categoria$produtosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    cursor?: ProdutoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Produto
   */

  export type AggregateProduto = {
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  export type ProdutoAvgAggregateOutputType = {
    id: number | null
    categoriaId: number | null
    preco: number | null
    estoque: number | null
  }

  export type ProdutoSumAggregateOutputType = {
    id: number | null
    categoriaId: number | null
    preco: number | null
    estoque: number | null
  }

  export type ProdutoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    categoriaId: number | null
    preco: number | null
    ativo: boolean | null
    foto: string | null
    tipoOpcao: string | null
    sabores: string | null
    isDrink: boolean | null
    isFood: boolean | null
    permitirObservacao: boolean | null
    permiteGeloLimao: boolean | null
    favorito: boolean | null
    ultimoUso: Date | null
    estoque: number | null
    esgotado: boolean | null
  }

  export type ProdutoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    categoriaId: number | null
    preco: number | null
    ativo: boolean | null
    foto: string | null
    tipoOpcao: string | null
    sabores: string | null
    isDrink: boolean | null
    isFood: boolean | null
    permitirObservacao: boolean | null
    permiteGeloLimao: boolean | null
    favorito: boolean | null
    ultimoUso: Date | null
    estoque: number | null
    esgotado: boolean | null
  }

  export type ProdutoCountAggregateOutputType = {
    id: number
    nome: number
    categoriaId: number
    preco: number
    ativo: number
    foto: number
    tipoOpcao: number
    sabores: number
    isDrink: number
    isFood: number
    permitirObservacao: number
    permiteGeloLimao: number
    favorito: number
    ultimoUso: number
    estoque: number
    esgotado: number
    _all: number
  }


  export type ProdutoAvgAggregateInputType = {
    id?: true
    categoriaId?: true
    preco?: true
    estoque?: true
  }

  export type ProdutoSumAggregateInputType = {
    id?: true
    categoriaId?: true
    preco?: true
    estoque?: true
  }

  export type ProdutoMinAggregateInputType = {
    id?: true
    nome?: true
    categoriaId?: true
    preco?: true
    ativo?: true
    foto?: true
    tipoOpcao?: true
    sabores?: true
    isDrink?: true
    isFood?: true
    permitirObservacao?: true
    permiteGeloLimao?: true
    favorito?: true
    ultimoUso?: true
    estoque?: true
    esgotado?: true
  }

  export type ProdutoMaxAggregateInputType = {
    id?: true
    nome?: true
    categoriaId?: true
    preco?: true
    ativo?: true
    foto?: true
    tipoOpcao?: true
    sabores?: true
    isDrink?: true
    isFood?: true
    permitirObservacao?: true
    permiteGeloLimao?: true
    favorito?: true
    ultimoUso?: true
    estoque?: true
    esgotado?: true
  }

  export type ProdutoCountAggregateInputType = {
    id?: true
    nome?: true
    categoriaId?: true
    preco?: true
    ativo?: true
    foto?: true
    tipoOpcao?: true
    sabores?: true
    isDrink?: true
    isFood?: true
    permitirObservacao?: true
    permiteGeloLimao?: true
    favorito?: true
    ultimoUso?: true
    estoque?: true
    esgotado?: true
    _all?: true
  }

  export type ProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produto to aggregate.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produtos
    **/
    _count?: true | ProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutoMaxAggregateInputType
  }

  export type GetProdutoAggregateType<T extends ProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduto[P]>
      : GetScalarType<T[P], AggregateProduto[P]>
  }




  export type ProdutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithAggregationInput | ProdutoOrderByWithAggregationInput[]
    by: ProdutoScalarFieldEnum[] | ProdutoScalarFieldEnum
    having?: ProdutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutoCountAggregateInputType | true
    _avg?: ProdutoAvgAggregateInputType
    _sum?: ProdutoSumAggregateInputType
    _min?: ProdutoMinAggregateInputType
    _max?: ProdutoMaxAggregateInputType
  }

  export type ProdutoGroupByOutputType = {
    id: number
    nome: string
    categoriaId: number | null
    preco: number
    ativo: boolean
    foto: string | null
    tipoOpcao: string
    sabores: string | null
    isDrink: boolean
    isFood: boolean
    permitirObservacao: boolean
    permiteGeloLimao: boolean
    favorito: boolean
    ultimoUso: Date | null
    estoque: number | null
    esgotado: boolean
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  type GetProdutoGroupByPayload<T extends ProdutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
        }
      >
    >


  export type ProdutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    categoriaId?: boolean
    preco?: boolean
    ativo?: boolean
    foto?: boolean
    tipoOpcao?: boolean
    sabores?: boolean
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: boolean
    estoque?: boolean
    esgotado?: boolean
    categoria?: boolean | Produto$categoriaArgs<ExtArgs>
    itens?: boolean | Produto$itensArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    categoriaId?: boolean
    preco?: boolean
    ativo?: boolean
    foto?: boolean
    tipoOpcao?: boolean
    sabores?: boolean
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: boolean
    estoque?: boolean
    esgotado?: boolean
    categoria?: boolean | Produto$categoriaArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectScalar = {
    id?: boolean
    nome?: boolean
    categoriaId?: boolean
    preco?: boolean
    ativo?: boolean
    foto?: boolean
    tipoOpcao?: boolean
    sabores?: boolean
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: boolean
    estoque?: boolean
    esgotado?: boolean
  }

  export type ProdutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | Produto$categoriaArgs<ExtArgs>
    itens?: boolean | Produto$itensArgs<ExtArgs>
    _count?: boolean | ProdutoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProdutoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | Produto$categoriaArgs<ExtArgs>
  }

  export type $ProdutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produto"
    objects: {
      categoria: Prisma.$CategoriaPayload<ExtArgs> | null
      itens: Prisma.$PedidoItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      categoriaId: number | null
      preco: number
      ativo: boolean
      foto: string | null
      tipoOpcao: string
      sabores: string | null
      isDrink: boolean
      isFood: boolean
      permitirObservacao: boolean
      permiteGeloLimao: boolean
      favorito: boolean
      ultimoUso: Date | null
      estoque: number | null
      esgotado: boolean
    }, ExtArgs["result"]["produto"]>
    composites: {}
  }

  type ProdutoGetPayload<S extends boolean | null | undefined | ProdutoDefaultArgs> = $Result.GetResult<Prisma.$ProdutoPayload, S>

  type ProdutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProdutoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdutoCountAggregateInputType | true
    }

  export interface ProdutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produto'], meta: { name: 'Produto' } }
    /**
     * Find zero or one Produto that matches the filter.
     * @param {ProdutoFindUniqueArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProdutoFindUniqueArgs>(args: SelectSubset<T, ProdutoFindUniqueArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Produto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProdutoFindUniqueOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProdutoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProdutoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProdutoFindFirstArgs>(args?: SelectSubset<T, ProdutoFindFirstArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProdutoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProdutoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produto.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtoWithIdOnly = await prisma.produto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProdutoFindManyArgs>(args?: SelectSubset<T, ProdutoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Produto.
     * @param {ProdutoCreateArgs} args - Arguments to create a Produto.
     * @example
     * // Create one Produto
     * const Produto = await prisma.produto.create({
     *   data: {
     *     // ... data to create a Produto
     *   }
     * })
     * 
     */
    create<T extends ProdutoCreateArgs>(args: SelectSubset<T, ProdutoCreateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Produtos.
     * @param {ProdutoCreateManyArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProdutoCreateManyArgs>(args?: SelectSubset<T, ProdutoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produtos and returns the data saved in the database.
     * @param {ProdutoCreateManyAndReturnArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produtos and only return the `id`
     * const produtoWithIdOnly = await prisma.produto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProdutoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProdutoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Produto.
     * @param {ProdutoDeleteArgs} args - Arguments to delete one Produto.
     * @example
     * // Delete one Produto
     * const Produto = await prisma.produto.delete({
     *   where: {
     *     // ... filter to delete one Produto
     *   }
     * })
     * 
     */
    delete<T extends ProdutoDeleteArgs>(args: SelectSubset<T, ProdutoDeleteArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Produto.
     * @param {ProdutoUpdateArgs} args - Arguments to update one Produto.
     * @example
     * // Update one Produto
     * const produto = await prisma.produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProdutoUpdateArgs>(args: SelectSubset<T, ProdutoUpdateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Produtos.
     * @param {ProdutoDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProdutoDeleteManyArgs>(args?: SelectSubset<T, ProdutoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProdutoUpdateManyArgs>(args: SelectSubset<T, ProdutoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produto.
     * @param {ProdutoUpsertArgs} args - Arguments to update or create a Produto.
     * @example
     * // Update or create a Produto
     * const produto = await prisma.produto.upsert({
     *   create: {
     *     // ... data to create a Produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produto we want to update
     *   }
     * })
     */
    upsert<T extends ProdutoUpsertArgs>(args: SelectSubset<T, ProdutoUpsertArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produto.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends ProdutoCountArgs>(
      args?: Subset<T, ProdutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutoAggregateArgs>(args: Subset<T, ProdutoAggregateArgs>): Prisma.PrismaPromise<GetProdutoAggregateType<T>>

    /**
     * Group by Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutoGroupByArgs['orderBy'] }
        : { orderBy?: ProdutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produto model
   */
  readonly fields: ProdutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends Produto$categoriaArgs<ExtArgs> = {}>(args?: Subset<T, Produto$categoriaArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    itens<T extends Produto$itensArgs<ExtArgs> = {}>(args?: Subset<T, Produto$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Produto model
   */ 
  interface ProdutoFieldRefs {
    readonly id: FieldRef<"Produto", 'Int'>
    readonly nome: FieldRef<"Produto", 'String'>
    readonly categoriaId: FieldRef<"Produto", 'Int'>
    readonly preco: FieldRef<"Produto", 'Float'>
    readonly ativo: FieldRef<"Produto", 'Boolean'>
    readonly foto: FieldRef<"Produto", 'String'>
    readonly tipoOpcao: FieldRef<"Produto", 'String'>
    readonly sabores: FieldRef<"Produto", 'String'>
    readonly isDrink: FieldRef<"Produto", 'Boolean'>
    readonly isFood: FieldRef<"Produto", 'Boolean'>
    readonly permitirObservacao: FieldRef<"Produto", 'Boolean'>
    readonly permiteGeloLimao: FieldRef<"Produto", 'Boolean'>
    readonly favorito: FieldRef<"Produto", 'Boolean'>
    readonly ultimoUso: FieldRef<"Produto", 'DateTime'>
    readonly estoque: FieldRef<"Produto", 'Int'>
    readonly esgotado: FieldRef<"Produto", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Produto findUnique
   */
  export type ProdutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findUniqueOrThrow
   */
  export type ProdutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findFirst
   */
  export type ProdutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findFirstOrThrow
   */
  export type ProdutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findMany
   */
  export type ProdutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produtos to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto create
   */
  export type ProdutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to create a Produto.
     */
    data: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
  }

  /**
   * Produto createMany
   */
  export type ProdutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Produto createManyAndReturn
   */
  export type ProdutoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produto update
   */
  export type ProdutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to update a Produto.
     */
    data: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
    /**
     * Choose, which Produto to update.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto updateMany
   */
  export type ProdutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produtos.
     */
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     */
    where?: ProdutoWhereInput
  }

  /**
   * Produto upsert
   */
  export type ProdutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The filter to search for the Produto to update in case it exists.
     */
    where: ProdutoWhereUniqueInput
    /**
     * In case the Produto found by the `where` argument doesn't exist, create a new Produto with this data.
     */
    create: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
    /**
     * In case the Produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
  }

  /**
   * Produto delete
   */
  export type ProdutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter which Produto to delete.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto deleteMany
   */
  export type ProdutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produtos to delete
     */
    where?: ProdutoWhereInput
  }

  /**
   * Produto.categoria
   */
  export type Produto$categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
  }

  /**
   * Produto.itens
   */
  export type Produto$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Produto without action
   */
  export type ProdutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
  }


  /**
   * Model PedidoItem
   */

  export type AggregatePedidoItem = {
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  export type PedidoItemAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    produtoId: number | null
    quantidade: number | null
  }

  export type PedidoItemSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    produtoId: number | null
    quantidade: number | null
  }

  export type PedidoItemMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    produtoId: number | null
    quantidade: number | null
    observacao: string | null
    status: string | null
  }

  export type PedidoItemMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    produtoId: number | null
    quantidade: number | null
    observacao: string | null
    status: string | null
  }

  export type PedidoItemCountAggregateOutputType = {
    id: number
    pedidoId: number
    produtoId: number
    quantidade: number
    observacao: number
    status: number
    _all: number
  }


  export type PedidoItemAvgAggregateInputType = {
    id?: true
    pedidoId?: true
    produtoId?: true
    quantidade?: true
  }

  export type PedidoItemSumAggregateInputType = {
    id?: true
    pedidoId?: true
    produtoId?: true
    quantidade?: true
  }

  export type PedidoItemMinAggregateInputType = {
    id?: true
    pedidoId?: true
    produtoId?: true
    quantidade?: true
    observacao?: true
    status?: true
  }

  export type PedidoItemMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    produtoId?: true
    quantidade?: true
    observacao?: true
    status?: true
  }

  export type PedidoItemCountAggregateInputType = {
    id?: true
    pedidoId?: true
    produtoId?: true
    quantidade?: true
    observacao?: true
    status?: true
    _all?: true
  }

  export type PedidoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItem to aggregate.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoItems
    **/
    _count?: true | PedidoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoItemMaxAggregateInputType
  }

  export type GetPedidoItemAggregateType<T extends PedidoItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoItem[P]>
      : GetScalarType<T[P], AggregatePedidoItem[P]>
  }




  export type PedidoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithAggregationInput | PedidoItemOrderByWithAggregationInput[]
    by: PedidoItemScalarFieldEnum[] | PedidoItemScalarFieldEnum
    having?: PedidoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoItemCountAggregateInputType | true
    _avg?: PedidoItemAvgAggregateInputType
    _sum?: PedidoItemSumAggregateInputType
    _min?: PedidoItemMinAggregateInputType
    _max?: PedidoItemMaxAggregateInputType
  }

  export type PedidoItemGroupByOutputType = {
    id: number
    pedidoId: number
    produtoId: number
    quantidade: number
    observacao: string | null
    status: string
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  type GetPedidoItemGroupByPayload<T extends PedidoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
        }
      >
    >


  export type PedidoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    produtoId?: boolean
    quantidade?: boolean
    observacao?: boolean
    status?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    ordemItens?: boolean | PedidoItem$ordemItensArgs<ExtArgs>
    _count?: boolean | PedidoItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>

  export type PedidoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    produtoId?: boolean
    quantidade?: boolean
    observacao?: boolean
    status?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>

  export type PedidoItemSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    produtoId?: boolean
    quantidade?: boolean
    observacao?: boolean
    status?: boolean
  }

  export type PedidoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
    ordemItens?: boolean | PedidoItem$ordemItensArgs<ExtArgs>
    _count?: boolean | PedidoItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PedidoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    produto?: boolean | ProdutoDefaultArgs<ExtArgs>
  }

  export type $PedidoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoItem"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      produto: Prisma.$ProdutoPayload<ExtArgs>
      ordemItens: Prisma.$OrdemItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number
      produtoId: number
      quantidade: number
      observacao: string | null
      status: string
    }, ExtArgs["result"]["pedidoItem"]>
    composites: {}
  }

  type PedidoItemGetPayload<S extends boolean | null | undefined | PedidoItemDefaultArgs> = $Result.GetResult<Prisma.$PedidoItemPayload, S>

  type PedidoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoItemCountAggregateInputType | true
    }

  export interface PedidoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoItem'], meta: { name: 'PedidoItem' } }
    /**
     * Find zero or one PedidoItem that matches the filter.
     * @param {PedidoItemFindUniqueArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoItemFindUniqueArgs>(args: SelectSubset<T, PedidoItemFindUniqueArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PedidoItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PedidoItemFindUniqueOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PedidoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoItemFindFirstArgs>(args?: SelectSubset<T, PedidoItemFindFirstArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PedidoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PedidoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany()
     * 
     * // Get first 10 PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoItemWithIdOnly = await prisma.pedidoItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoItemFindManyArgs>(args?: SelectSubset<T, PedidoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PedidoItem.
     * @param {PedidoItemCreateArgs} args - Arguments to create a PedidoItem.
     * @example
     * // Create one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.create({
     *   data: {
     *     // ... data to create a PedidoItem
     *   }
     * })
     * 
     */
    create<T extends PedidoItemCreateArgs>(args: SelectSubset<T, PedidoItemCreateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PedidoItems.
     * @param {PedidoItemCreateManyArgs} args - Arguments to create many PedidoItems.
     * @example
     * // Create many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoItemCreateManyArgs>(args?: SelectSubset<T, PedidoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PedidoItems and returns the data saved in the database.
     * @param {PedidoItemCreateManyAndReturnArgs} args - Arguments to create many PedidoItems.
     * @example
     * // Create many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PedidoItems and only return the `id`
     * const pedidoItemWithIdOnly = await prisma.pedidoItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PedidoItem.
     * @param {PedidoItemDeleteArgs} args - Arguments to delete one PedidoItem.
     * @example
     * // Delete one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.delete({
     *   where: {
     *     // ... filter to delete one PedidoItem
     *   }
     * })
     * 
     */
    delete<T extends PedidoItemDeleteArgs>(args: SelectSubset<T, PedidoItemDeleteArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PedidoItem.
     * @param {PedidoItemUpdateArgs} args - Arguments to update one PedidoItem.
     * @example
     * // Update one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoItemUpdateArgs>(args: SelectSubset<T, PedidoItemUpdateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PedidoItems.
     * @param {PedidoItemDeleteManyArgs} args - Arguments to filter PedidoItems to delete.
     * @example
     * // Delete a few PedidoItems
     * const { count } = await prisma.pedidoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoItemDeleteManyArgs>(args?: SelectSubset<T, PedidoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoItemUpdateManyArgs>(args: SelectSubset<T, PedidoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoItem.
     * @param {PedidoItemUpsertArgs} args - Arguments to update or create a PedidoItem.
     * @example
     * // Update or create a PedidoItem
     * const pedidoItem = await prisma.pedidoItem.upsert({
     *   create: {
     *     // ... data to create a PedidoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoItem we want to update
     *   }
     * })
     */
    upsert<T extends PedidoItemUpsertArgs>(args: SelectSubset<T, PedidoItemUpsertArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemCountArgs} args - Arguments to filter PedidoItems to count.
     * @example
     * // Count the number of PedidoItems
     * const count = await prisma.pedidoItem.count({
     *   where: {
     *     // ... the filter for the PedidoItems we want to count
     *   }
     * })
    **/
    count<T extends PedidoItemCountArgs>(
      args?: Subset<T, PedidoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoItemAggregateArgs>(args: Subset<T, PedidoItemAggregateArgs>): Prisma.PrismaPromise<GetPedidoItemAggregateType<T>>

    /**
     * Group by PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoItemGroupByArgs['orderBy'] }
        : { orderBy?: PedidoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoItem model
   */
  readonly fields: PedidoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    produto<T extends ProdutoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProdutoDefaultArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ordemItens<T extends PedidoItem$ordemItensArgs<ExtArgs> = {}>(args?: Subset<T, PedidoItem$ordemItensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PedidoItem model
   */ 
  interface PedidoItemFieldRefs {
    readonly id: FieldRef<"PedidoItem", 'Int'>
    readonly pedidoId: FieldRef<"PedidoItem", 'Int'>
    readonly produtoId: FieldRef<"PedidoItem", 'Int'>
    readonly quantidade: FieldRef<"PedidoItem", 'Int'>
    readonly observacao: FieldRef<"PedidoItem", 'String'>
    readonly status: FieldRef<"PedidoItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PedidoItem findUnique
   */
  export type PedidoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findUniqueOrThrow
   */
  export type PedidoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findFirst
   */
  export type PedidoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findFirstOrThrow
   */
  export type PedidoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findMany
   */
  export type PedidoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItems to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem create
   */
  export type PedidoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoItem.
     */
    data: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
  }

  /**
   * PedidoItem createMany
   */
  export type PedidoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoItems.
     */
    data: PedidoItemCreateManyInput | PedidoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PedidoItem createManyAndReturn
   */
  export type PedidoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PedidoItems.
     */
    data: PedidoItemCreateManyInput | PedidoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoItem update
   */
  export type PedidoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoItem.
     */
    data: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
    /**
     * Choose, which PedidoItem to update.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem updateMany
   */
  export type PedidoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoItems.
     */
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyInput>
    /**
     * Filter which PedidoItems to update
     */
    where?: PedidoItemWhereInput
  }

  /**
   * PedidoItem upsert
   */
  export type PedidoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoItem to update in case it exists.
     */
    where: PedidoItemWhereUniqueInput
    /**
     * In case the PedidoItem found by the `where` argument doesn't exist, create a new PedidoItem with this data.
     */
    create: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
    /**
     * In case the PedidoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
  }

  /**
   * PedidoItem delete
   */
  export type PedidoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter which PedidoItem to delete.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem deleteMany
   */
  export type PedidoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItems to delete
     */
    where?: PedidoItemWhereInput
  }

  /**
   * PedidoItem.ordemItens
   */
  export type PedidoItem$ordemItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    where?: OrdemItemWhereInput
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    cursor?: OrdemItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdemItemScalarFieldEnum | OrdemItemScalarFieldEnum[]
  }

  /**
   * PedidoItem without action
   */
  export type PedidoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
  }


  /**
   * Model OrdemProducao
   */

  export type AggregateOrdemProducao = {
    _count: OrdemProducaoCountAggregateOutputType | null
    _avg: OrdemProducaoAvgAggregateOutputType | null
    _sum: OrdemProducaoSumAggregateOutputType | null
    _min: OrdemProducaoMinAggregateOutputType | null
    _max: OrdemProducaoMaxAggregateOutputType | null
  }

  export type OrdemProducaoAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
  }

  export type OrdemProducaoSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
  }

  export type OrdemProducaoMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    setor: string | null
    status: string | null
    criadaEm: Date | null
    finalizadaEm: Date | null
  }

  export type OrdemProducaoMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    setor: string | null
    status: string | null
    criadaEm: Date | null
    finalizadaEm: Date | null
  }

  export type OrdemProducaoCountAggregateOutputType = {
    id: number
    pedidoId: number
    setor: number
    status: number
    criadaEm: number
    finalizadaEm: number
    _all: number
  }


  export type OrdemProducaoAvgAggregateInputType = {
    id?: true
    pedidoId?: true
  }

  export type OrdemProducaoSumAggregateInputType = {
    id?: true
    pedidoId?: true
  }

  export type OrdemProducaoMinAggregateInputType = {
    id?: true
    pedidoId?: true
    setor?: true
    status?: true
    criadaEm?: true
    finalizadaEm?: true
  }

  export type OrdemProducaoMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    setor?: true
    status?: true
    criadaEm?: true
    finalizadaEm?: true
  }

  export type OrdemProducaoCountAggregateInputType = {
    id?: true
    pedidoId?: true
    setor?: true
    status?: true
    criadaEm?: true
    finalizadaEm?: true
    _all?: true
  }

  export type OrdemProducaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemProducao to aggregate.
     */
    where?: OrdemProducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemProducaos to fetch.
     */
    orderBy?: OrdemProducaoOrderByWithRelationInput | OrdemProducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdemProducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemProducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemProducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdemProducaos
    **/
    _count?: true | OrdemProducaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdemProducaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdemProducaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdemProducaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdemProducaoMaxAggregateInputType
  }

  export type GetOrdemProducaoAggregateType<T extends OrdemProducaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdemProducao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdemProducao[P]>
      : GetScalarType<T[P], AggregateOrdemProducao[P]>
  }




  export type OrdemProducaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemProducaoWhereInput
    orderBy?: OrdemProducaoOrderByWithAggregationInput | OrdemProducaoOrderByWithAggregationInput[]
    by: OrdemProducaoScalarFieldEnum[] | OrdemProducaoScalarFieldEnum
    having?: OrdemProducaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdemProducaoCountAggregateInputType | true
    _avg?: OrdemProducaoAvgAggregateInputType
    _sum?: OrdemProducaoSumAggregateInputType
    _min?: OrdemProducaoMinAggregateInputType
    _max?: OrdemProducaoMaxAggregateInputType
  }

  export type OrdemProducaoGroupByOutputType = {
    id: number
    pedidoId: number
    setor: string
    status: string
    criadaEm: Date
    finalizadaEm: Date | null
    _count: OrdemProducaoCountAggregateOutputType | null
    _avg: OrdemProducaoAvgAggregateOutputType | null
    _sum: OrdemProducaoSumAggregateOutputType | null
    _min: OrdemProducaoMinAggregateOutputType | null
    _max: OrdemProducaoMaxAggregateOutputType | null
  }

  type GetOrdemProducaoGroupByPayload<T extends OrdemProducaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdemProducaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdemProducaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdemProducaoGroupByOutputType[P]>
            : GetScalarType<T[P], OrdemProducaoGroupByOutputType[P]>
        }
      >
    >


  export type OrdemProducaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    setor?: boolean
    status?: boolean
    criadaEm?: boolean
    finalizadaEm?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    itens?: boolean | OrdemProducao$itensArgs<ExtArgs>
    _count?: boolean | OrdemProducaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemProducao"]>

  export type OrdemProducaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    setor?: boolean
    status?: boolean
    criadaEm?: boolean
    finalizadaEm?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemProducao"]>

  export type OrdemProducaoSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    setor?: boolean
    status?: boolean
    criadaEm?: boolean
    finalizadaEm?: boolean
  }

  export type OrdemProducaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    itens?: boolean | OrdemProducao$itensArgs<ExtArgs>
    _count?: boolean | OrdemProducaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrdemProducaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }

  export type $OrdemProducaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrdemProducao"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      itens: Prisma.$OrdemItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number
      setor: string
      status: string
      criadaEm: Date
      finalizadaEm: Date | null
    }, ExtArgs["result"]["ordemProducao"]>
    composites: {}
  }

  type OrdemProducaoGetPayload<S extends boolean | null | undefined | OrdemProducaoDefaultArgs> = $Result.GetResult<Prisma.$OrdemProducaoPayload, S>

  type OrdemProducaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrdemProducaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrdemProducaoCountAggregateInputType | true
    }

  export interface OrdemProducaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdemProducao'], meta: { name: 'OrdemProducao' } }
    /**
     * Find zero or one OrdemProducao that matches the filter.
     * @param {OrdemProducaoFindUniqueArgs} args - Arguments to find a OrdemProducao
     * @example
     * // Get one OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdemProducaoFindUniqueArgs>(args: SelectSubset<T, OrdemProducaoFindUniqueArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrdemProducao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrdemProducaoFindUniqueOrThrowArgs} args - Arguments to find a OrdemProducao
     * @example
     * // Get one OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdemProducaoFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdemProducaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrdemProducao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoFindFirstArgs} args - Arguments to find a OrdemProducao
     * @example
     * // Get one OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdemProducaoFindFirstArgs>(args?: SelectSubset<T, OrdemProducaoFindFirstArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrdemProducao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoFindFirstOrThrowArgs} args - Arguments to find a OrdemProducao
     * @example
     * // Get one OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdemProducaoFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdemProducaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrdemProducaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdemProducaos
     * const ordemProducaos = await prisma.ordemProducao.findMany()
     * 
     * // Get first 10 OrdemProducaos
     * const ordemProducaos = await prisma.ordemProducao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordemProducaoWithIdOnly = await prisma.ordemProducao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdemProducaoFindManyArgs>(args?: SelectSubset<T, OrdemProducaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrdemProducao.
     * @param {OrdemProducaoCreateArgs} args - Arguments to create a OrdemProducao.
     * @example
     * // Create one OrdemProducao
     * const OrdemProducao = await prisma.ordemProducao.create({
     *   data: {
     *     // ... data to create a OrdemProducao
     *   }
     * })
     * 
     */
    create<T extends OrdemProducaoCreateArgs>(args: SelectSubset<T, OrdemProducaoCreateArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrdemProducaos.
     * @param {OrdemProducaoCreateManyArgs} args - Arguments to create many OrdemProducaos.
     * @example
     * // Create many OrdemProducaos
     * const ordemProducao = await prisma.ordemProducao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdemProducaoCreateManyArgs>(args?: SelectSubset<T, OrdemProducaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrdemProducaos and returns the data saved in the database.
     * @param {OrdemProducaoCreateManyAndReturnArgs} args - Arguments to create many OrdemProducaos.
     * @example
     * // Create many OrdemProducaos
     * const ordemProducao = await prisma.ordemProducao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrdemProducaos and only return the `id`
     * const ordemProducaoWithIdOnly = await prisma.ordemProducao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdemProducaoCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdemProducaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrdemProducao.
     * @param {OrdemProducaoDeleteArgs} args - Arguments to delete one OrdemProducao.
     * @example
     * // Delete one OrdemProducao
     * const OrdemProducao = await prisma.ordemProducao.delete({
     *   where: {
     *     // ... filter to delete one OrdemProducao
     *   }
     * })
     * 
     */
    delete<T extends OrdemProducaoDeleteArgs>(args: SelectSubset<T, OrdemProducaoDeleteArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrdemProducao.
     * @param {OrdemProducaoUpdateArgs} args - Arguments to update one OrdemProducao.
     * @example
     * // Update one OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdemProducaoUpdateArgs>(args: SelectSubset<T, OrdemProducaoUpdateArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrdemProducaos.
     * @param {OrdemProducaoDeleteManyArgs} args - Arguments to filter OrdemProducaos to delete.
     * @example
     * // Delete a few OrdemProducaos
     * const { count } = await prisma.ordemProducao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdemProducaoDeleteManyArgs>(args?: SelectSubset<T, OrdemProducaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdemProducaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdemProducaos
     * const ordemProducao = await prisma.ordemProducao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdemProducaoUpdateManyArgs>(args: SelectSubset<T, OrdemProducaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrdemProducao.
     * @param {OrdemProducaoUpsertArgs} args - Arguments to update or create a OrdemProducao.
     * @example
     * // Update or create a OrdemProducao
     * const ordemProducao = await prisma.ordemProducao.upsert({
     *   create: {
     *     // ... data to create a OrdemProducao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdemProducao we want to update
     *   }
     * })
     */
    upsert<T extends OrdemProducaoUpsertArgs>(args: SelectSubset<T, OrdemProducaoUpsertArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrdemProducaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoCountArgs} args - Arguments to filter OrdemProducaos to count.
     * @example
     * // Count the number of OrdemProducaos
     * const count = await prisma.ordemProducao.count({
     *   where: {
     *     // ... the filter for the OrdemProducaos we want to count
     *   }
     * })
    **/
    count<T extends OrdemProducaoCountArgs>(
      args?: Subset<T, OrdemProducaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdemProducaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdemProducao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdemProducaoAggregateArgs>(args: Subset<T, OrdemProducaoAggregateArgs>): Prisma.PrismaPromise<GetOrdemProducaoAggregateType<T>>

    /**
     * Group by OrdemProducao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemProducaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdemProducaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdemProducaoGroupByArgs['orderBy'] }
        : { orderBy?: OrdemProducaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdemProducaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdemProducaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdemProducao model
   */
  readonly fields: OrdemProducaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdemProducao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdemProducaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    itens<T extends OrdemProducao$itensArgs<ExtArgs> = {}>(args?: Subset<T, OrdemProducao$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrdemProducao model
   */ 
  interface OrdemProducaoFieldRefs {
    readonly id: FieldRef<"OrdemProducao", 'Int'>
    readonly pedidoId: FieldRef<"OrdemProducao", 'Int'>
    readonly setor: FieldRef<"OrdemProducao", 'String'>
    readonly status: FieldRef<"OrdemProducao", 'String'>
    readonly criadaEm: FieldRef<"OrdemProducao", 'DateTime'>
    readonly finalizadaEm: FieldRef<"OrdemProducao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrdemProducao findUnique
   */
  export type OrdemProducaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemProducao to fetch.
     */
    where: OrdemProducaoWhereUniqueInput
  }

  /**
   * OrdemProducao findUniqueOrThrow
   */
  export type OrdemProducaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemProducao to fetch.
     */
    where: OrdemProducaoWhereUniqueInput
  }

  /**
   * OrdemProducao findFirst
   */
  export type OrdemProducaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemProducao to fetch.
     */
    where?: OrdemProducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemProducaos to fetch.
     */
    orderBy?: OrdemProducaoOrderByWithRelationInput | OrdemProducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemProducaos.
     */
    cursor?: OrdemProducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemProducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemProducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemProducaos.
     */
    distinct?: OrdemProducaoScalarFieldEnum | OrdemProducaoScalarFieldEnum[]
  }

  /**
   * OrdemProducao findFirstOrThrow
   */
  export type OrdemProducaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemProducao to fetch.
     */
    where?: OrdemProducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemProducaos to fetch.
     */
    orderBy?: OrdemProducaoOrderByWithRelationInput | OrdemProducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemProducaos.
     */
    cursor?: OrdemProducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemProducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemProducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemProducaos.
     */
    distinct?: OrdemProducaoScalarFieldEnum | OrdemProducaoScalarFieldEnum[]
  }

  /**
   * OrdemProducao findMany
   */
  export type OrdemProducaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemProducaos to fetch.
     */
    where?: OrdemProducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemProducaos to fetch.
     */
    orderBy?: OrdemProducaoOrderByWithRelationInput | OrdemProducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdemProducaos.
     */
    cursor?: OrdemProducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemProducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemProducaos.
     */
    skip?: number
    distinct?: OrdemProducaoScalarFieldEnum | OrdemProducaoScalarFieldEnum[]
  }

  /**
   * OrdemProducao create
   */
  export type OrdemProducaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdemProducao.
     */
    data: XOR<OrdemProducaoCreateInput, OrdemProducaoUncheckedCreateInput>
  }

  /**
   * OrdemProducao createMany
   */
  export type OrdemProducaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdemProducaos.
     */
    data: OrdemProducaoCreateManyInput | OrdemProducaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrdemProducao createManyAndReturn
   */
  export type OrdemProducaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrdemProducaos.
     */
    data: OrdemProducaoCreateManyInput | OrdemProducaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrdemProducao update
   */
  export type OrdemProducaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdemProducao.
     */
    data: XOR<OrdemProducaoUpdateInput, OrdemProducaoUncheckedUpdateInput>
    /**
     * Choose, which OrdemProducao to update.
     */
    where: OrdemProducaoWhereUniqueInput
  }

  /**
   * OrdemProducao updateMany
   */
  export type OrdemProducaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdemProducaos.
     */
    data: XOR<OrdemProducaoUpdateManyMutationInput, OrdemProducaoUncheckedUpdateManyInput>
    /**
     * Filter which OrdemProducaos to update
     */
    where?: OrdemProducaoWhereInput
  }

  /**
   * OrdemProducao upsert
   */
  export type OrdemProducaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdemProducao to update in case it exists.
     */
    where: OrdemProducaoWhereUniqueInput
    /**
     * In case the OrdemProducao found by the `where` argument doesn't exist, create a new OrdemProducao with this data.
     */
    create: XOR<OrdemProducaoCreateInput, OrdemProducaoUncheckedCreateInput>
    /**
     * In case the OrdemProducao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdemProducaoUpdateInput, OrdemProducaoUncheckedUpdateInput>
  }

  /**
   * OrdemProducao delete
   */
  export type OrdemProducaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
    /**
     * Filter which OrdemProducao to delete.
     */
    where: OrdemProducaoWhereUniqueInput
  }

  /**
   * OrdemProducao deleteMany
   */
  export type OrdemProducaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemProducaos to delete
     */
    where?: OrdemProducaoWhereInput
  }

  /**
   * OrdemProducao.itens
   */
  export type OrdemProducao$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    where?: OrdemItemWhereInput
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    cursor?: OrdemItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdemItemScalarFieldEnum | OrdemItemScalarFieldEnum[]
  }

  /**
   * OrdemProducao without action
   */
  export type OrdemProducaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemProducao
     */
    select?: OrdemProducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemProducaoInclude<ExtArgs> | null
  }


  /**
   * Model OrdemItem
   */

  export type AggregateOrdemItem = {
    _count: OrdemItemCountAggregateOutputType | null
    _avg: OrdemItemAvgAggregateOutputType | null
    _sum: OrdemItemSumAggregateOutputType | null
    _min: OrdemItemMinAggregateOutputType | null
    _max: OrdemItemMaxAggregateOutputType | null
  }

  export type OrdemItemAvgAggregateOutputType = {
    id: number | null
    ordemProducaoId: number | null
    pedidoItemId: number | null
  }

  export type OrdemItemSumAggregateOutputType = {
    id: number | null
    ordemProducaoId: number | null
    pedidoItemId: number | null
  }

  export type OrdemItemMinAggregateOutputType = {
    id: number | null
    ordemProducaoId: number | null
    pedidoItemId: number | null
  }

  export type OrdemItemMaxAggregateOutputType = {
    id: number | null
    ordemProducaoId: number | null
    pedidoItemId: number | null
  }

  export type OrdemItemCountAggregateOutputType = {
    id: number
    ordemProducaoId: number
    pedidoItemId: number
    _all: number
  }


  export type OrdemItemAvgAggregateInputType = {
    id?: true
    ordemProducaoId?: true
    pedidoItemId?: true
  }

  export type OrdemItemSumAggregateInputType = {
    id?: true
    ordemProducaoId?: true
    pedidoItemId?: true
  }

  export type OrdemItemMinAggregateInputType = {
    id?: true
    ordemProducaoId?: true
    pedidoItemId?: true
  }

  export type OrdemItemMaxAggregateInputType = {
    id?: true
    ordemProducaoId?: true
    pedidoItemId?: true
  }

  export type OrdemItemCountAggregateInputType = {
    id?: true
    ordemProducaoId?: true
    pedidoItemId?: true
    _all?: true
  }

  export type OrdemItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemItem to aggregate.
     */
    where?: OrdemItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemItems to fetch.
     */
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdemItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdemItems
    **/
    _count?: true | OrdemItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdemItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdemItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdemItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdemItemMaxAggregateInputType
  }

  export type GetOrdemItemAggregateType<T extends OrdemItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdemItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdemItem[P]>
      : GetScalarType<T[P], AggregateOrdemItem[P]>
  }




  export type OrdemItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemItemWhereInput
    orderBy?: OrdemItemOrderByWithAggregationInput | OrdemItemOrderByWithAggregationInput[]
    by: OrdemItemScalarFieldEnum[] | OrdemItemScalarFieldEnum
    having?: OrdemItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdemItemCountAggregateInputType | true
    _avg?: OrdemItemAvgAggregateInputType
    _sum?: OrdemItemSumAggregateInputType
    _min?: OrdemItemMinAggregateInputType
    _max?: OrdemItemMaxAggregateInputType
  }

  export type OrdemItemGroupByOutputType = {
    id: number
    ordemProducaoId: number
    pedidoItemId: number
    _count: OrdemItemCountAggregateOutputType | null
    _avg: OrdemItemAvgAggregateOutputType | null
    _sum: OrdemItemSumAggregateOutputType | null
    _min: OrdemItemMinAggregateOutputType | null
    _max: OrdemItemMaxAggregateOutputType | null
  }

  type GetOrdemItemGroupByPayload<T extends OrdemItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdemItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdemItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdemItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrdemItemGroupByOutputType[P]>
        }
      >
    >


  export type OrdemItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordemProducaoId?: boolean
    pedidoItemId?: boolean
    ordemProducao?: boolean | OrdemProducaoDefaultArgs<ExtArgs>
    pedidoItem?: boolean | PedidoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemItem"]>

  export type OrdemItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordemProducaoId?: boolean
    pedidoItemId?: boolean
    ordemProducao?: boolean | OrdemProducaoDefaultArgs<ExtArgs>
    pedidoItem?: boolean | PedidoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemItem"]>

  export type OrdemItemSelectScalar = {
    id?: boolean
    ordemProducaoId?: boolean
    pedidoItemId?: boolean
  }

  export type OrdemItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordemProducao?: boolean | OrdemProducaoDefaultArgs<ExtArgs>
    pedidoItem?: boolean | PedidoItemDefaultArgs<ExtArgs>
  }
  export type OrdemItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordemProducao?: boolean | OrdemProducaoDefaultArgs<ExtArgs>
    pedidoItem?: boolean | PedidoItemDefaultArgs<ExtArgs>
  }

  export type $OrdemItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrdemItem"
    objects: {
      ordemProducao: Prisma.$OrdemProducaoPayload<ExtArgs>
      pedidoItem: Prisma.$PedidoItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ordemProducaoId: number
      pedidoItemId: number
    }, ExtArgs["result"]["ordemItem"]>
    composites: {}
  }

  type OrdemItemGetPayload<S extends boolean | null | undefined | OrdemItemDefaultArgs> = $Result.GetResult<Prisma.$OrdemItemPayload, S>

  type OrdemItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrdemItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrdemItemCountAggregateInputType | true
    }

  export interface OrdemItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdemItem'], meta: { name: 'OrdemItem' } }
    /**
     * Find zero or one OrdemItem that matches the filter.
     * @param {OrdemItemFindUniqueArgs} args - Arguments to find a OrdemItem
     * @example
     * // Get one OrdemItem
     * const ordemItem = await prisma.ordemItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdemItemFindUniqueArgs>(args: SelectSubset<T, OrdemItemFindUniqueArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrdemItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrdemItemFindUniqueOrThrowArgs} args - Arguments to find a OrdemItem
     * @example
     * // Get one OrdemItem
     * const ordemItem = await prisma.ordemItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdemItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdemItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrdemItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemFindFirstArgs} args - Arguments to find a OrdemItem
     * @example
     * // Get one OrdemItem
     * const ordemItem = await prisma.ordemItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdemItemFindFirstArgs>(args?: SelectSubset<T, OrdemItemFindFirstArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrdemItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemFindFirstOrThrowArgs} args - Arguments to find a OrdemItem
     * @example
     * // Get one OrdemItem
     * const ordemItem = await prisma.ordemItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdemItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdemItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrdemItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdemItems
     * const ordemItems = await prisma.ordemItem.findMany()
     * 
     * // Get first 10 OrdemItems
     * const ordemItems = await prisma.ordemItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordemItemWithIdOnly = await prisma.ordemItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdemItemFindManyArgs>(args?: SelectSubset<T, OrdemItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrdemItem.
     * @param {OrdemItemCreateArgs} args - Arguments to create a OrdemItem.
     * @example
     * // Create one OrdemItem
     * const OrdemItem = await prisma.ordemItem.create({
     *   data: {
     *     // ... data to create a OrdemItem
     *   }
     * })
     * 
     */
    create<T extends OrdemItemCreateArgs>(args: SelectSubset<T, OrdemItemCreateArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrdemItems.
     * @param {OrdemItemCreateManyArgs} args - Arguments to create many OrdemItems.
     * @example
     * // Create many OrdemItems
     * const ordemItem = await prisma.ordemItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdemItemCreateManyArgs>(args?: SelectSubset<T, OrdemItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrdemItems and returns the data saved in the database.
     * @param {OrdemItemCreateManyAndReturnArgs} args - Arguments to create many OrdemItems.
     * @example
     * // Create many OrdemItems
     * const ordemItem = await prisma.ordemItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrdemItems and only return the `id`
     * const ordemItemWithIdOnly = await prisma.ordemItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdemItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdemItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrdemItem.
     * @param {OrdemItemDeleteArgs} args - Arguments to delete one OrdemItem.
     * @example
     * // Delete one OrdemItem
     * const OrdemItem = await prisma.ordemItem.delete({
     *   where: {
     *     // ... filter to delete one OrdemItem
     *   }
     * })
     * 
     */
    delete<T extends OrdemItemDeleteArgs>(args: SelectSubset<T, OrdemItemDeleteArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrdemItem.
     * @param {OrdemItemUpdateArgs} args - Arguments to update one OrdemItem.
     * @example
     * // Update one OrdemItem
     * const ordemItem = await prisma.ordemItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdemItemUpdateArgs>(args: SelectSubset<T, OrdemItemUpdateArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrdemItems.
     * @param {OrdemItemDeleteManyArgs} args - Arguments to filter OrdemItems to delete.
     * @example
     * // Delete a few OrdemItems
     * const { count } = await prisma.ordemItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdemItemDeleteManyArgs>(args?: SelectSubset<T, OrdemItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdemItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdemItems
     * const ordemItem = await prisma.ordemItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdemItemUpdateManyArgs>(args: SelectSubset<T, OrdemItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrdemItem.
     * @param {OrdemItemUpsertArgs} args - Arguments to update or create a OrdemItem.
     * @example
     * // Update or create a OrdemItem
     * const ordemItem = await prisma.ordemItem.upsert({
     *   create: {
     *     // ... data to create a OrdemItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdemItem we want to update
     *   }
     * })
     */
    upsert<T extends OrdemItemUpsertArgs>(args: SelectSubset<T, OrdemItemUpsertArgs<ExtArgs>>): Prisma__OrdemItemClient<$Result.GetResult<Prisma.$OrdemItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrdemItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemCountArgs} args - Arguments to filter OrdemItems to count.
     * @example
     * // Count the number of OrdemItems
     * const count = await prisma.ordemItem.count({
     *   where: {
     *     // ... the filter for the OrdemItems we want to count
     *   }
     * })
    **/
    count<T extends OrdemItemCountArgs>(
      args?: Subset<T, OrdemItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdemItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdemItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdemItemAggregateArgs>(args: Subset<T, OrdemItemAggregateArgs>): Prisma.PrismaPromise<GetOrdemItemAggregateType<T>>

    /**
     * Group by OrdemItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdemItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdemItemGroupByArgs['orderBy'] }
        : { orderBy?: OrdemItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdemItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdemItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdemItem model
   */
  readonly fields: OrdemItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdemItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdemItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordemProducao<T extends OrdemProducaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdemProducaoDefaultArgs<ExtArgs>>): Prisma__OrdemProducaoClient<$Result.GetResult<Prisma.$OrdemProducaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pedidoItem<T extends PedidoItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoItemDefaultArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrdemItem model
   */ 
  interface OrdemItemFieldRefs {
    readonly id: FieldRef<"OrdemItem", 'Int'>
    readonly ordemProducaoId: FieldRef<"OrdemItem", 'Int'>
    readonly pedidoItemId: FieldRef<"OrdemItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrdemItem findUnique
   */
  export type OrdemItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdemItem to fetch.
     */
    where: OrdemItemWhereUniqueInput
  }

  /**
   * OrdemItem findUniqueOrThrow
   */
  export type OrdemItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdemItem to fetch.
     */
    where: OrdemItemWhereUniqueInput
  }

  /**
   * OrdemItem findFirst
   */
  export type OrdemItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdemItem to fetch.
     */
    where?: OrdemItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemItems to fetch.
     */
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemItems.
     */
    cursor?: OrdemItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemItems.
     */
    distinct?: OrdemItemScalarFieldEnum | OrdemItemScalarFieldEnum[]
  }

  /**
   * OrdemItem findFirstOrThrow
   */
  export type OrdemItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdemItem to fetch.
     */
    where?: OrdemItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemItems to fetch.
     */
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemItems.
     */
    cursor?: OrdemItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemItems.
     */
    distinct?: OrdemItemScalarFieldEnum | OrdemItemScalarFieldEnum[]
  }

  /**
   * OrdemItem findMany
   */
  export type OrdemItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter, which OrdemItems to fetch.
     */
    where?: OrdemItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemItems to fetch.
     */
    orderBy?: OrdemItemOrderByWithRelationInput | OrdemItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdemItems.
     */
    cursor?: OrdemItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemItems.
     */
    skip?: number
    distinct?: OrdemItemScalarFieldEnum | OrdemItemScalarFieldEnum[]
  }

  /**
   * OrdemItem create
   */
  export type OrdemItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdemItem.
     */
    data: XOR<OrdemItemCreateInput, OrdemItemUncheckedCreateInput>
  }

  /**
   * OrdemItem createMany
   */
  export type OrdemItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdemItems.
     */
    data: OrdemItemCreateManyInput | OrdemItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrdemItem createManyAndReturn
   */
  export type OrdemItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrdemItems.
     */
    data: OrdemItemCreateManyInput | OrdemItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrdemItem update
   */
  export type OrdemItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdemItem.
     */
    data: XOR<OrdemItemUpdateInput, OrdemItemUncheckedUpdateInput>
    /**
     * Choose, which OrdemItem to update.
     */
    where: OrdemItemWhereUniqueInput
  }

  /**
   * OrdemItem updateMany
   */
  export type OrdemItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdemItems.
     */
    data: XOR<OrdemItemUpdateManyMutationInput, OrdemItemUncheckedUpdateManyInput>
    /**
     * Filter which OrdemItems to update
     */
    where?: OrdemItemWhereInput
  }

  /**
   * OrdemItem upsert
   */
  export type OrdemItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdemItem to update in case it exists.
     */
    where: OrdemItemWhereUniqueInput
    /**
     * In case the OrdemItem found by the `where` argument doesn't exist, create a new OrdemItem with this data.
     */
    create: XOR<OrdemItemCreateInput, OrdemItemUncheckedCreateInput>
    /**
     * In case the OrdemItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdemItemUpdateInput, OrdemItemUncheckedUpdateInput>
  }

  /**
   * OrdemItem delete
   */
  export type OrdemItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
    /**
     * Filter which OrdemItem to delete.
     */
    where: OrdemItemWhereUniqueInput
  }

  /**
   * OrdemItem deleteMany
   */
  export type OrdemItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemItems to delete
     */
    where?: OrdemItemWhereInput
  }

  /**
   * OrdemItem without action
   */
  export type OrdemItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemItem
     */
    select?: OrdemItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemItemInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    id: number | null
    comandaId: number | null
    valor: number | null
  }

  export type PagamentoSumAggregateOutputType = {
    id: number | null
    comandaId: number | null
    valor: number | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: number | null
    comandaId: number | null
    tipo: string | null
    valor: number | null
    status: string | null
    criadoEm: Date | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: number | null
    comandaId: number | null
    tipo: string | null
    valor: number | null
    status: string | null
    criadoEm: Date | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    comandaId: number
    tipo: number
    valor: number
    status: number
    criadoEm: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    id?: true
    comandaId?: true
    valor?: true
  }

  export type PagamentoSumAggregateInputType = {
    id?: true
    comandaId?: true
    valor?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    comandaId?: true
    tipo?: true
    valor?: true
    status?: true
    criadoEm?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    comandaId?: true
    tipo?: true
    valor?: true
    status?: true
    criadoEm?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    comandaId?: true
    tipo?: true
    valor?: true
    status?: true
    criadoEm?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: number
    comandaId: number
    tipo: string
    valor: number
    status: string
    criadoEm: Date
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comandaId?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    criadoEm?: boolean
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comandaId?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    criadoEm?: boolean
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    comandaId?: boolean
    tipo?: boolean
    valor?: boolean
    status?: boolean
    criadoEm?: boolean
  }

  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
  }
  export type PagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comanda?: boolean | ComandaDefaultArgs<ExtArgs>
  }

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      comanda: Prisma.$ComandaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      comandaId: number
      tipo: string
      valor: number
      status: string
      criadoEm: Date
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos and returns the data saved in the database.
     * @param {PagamentoCreateManyAndReturnArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comanda<T extends ComandaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComandaDefaultArgs<ExtArgs>>): Prisma__ComandaClient<$Result.GetResult<Prisma.$ComandaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */ 
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'Int'>
    readonly comandaId: FieldRef<"Pagamento", 'Int'>
    readonly tipo: FieldRef<"Pagamento", 'String'>
    readonly valor: FieldRef<"Pagamento", 'Float'>
    readonly status: FieldRef<"Pagamento", 'String'>
    readonly criadoEm: FieldRef<"Pagamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento createManyAndReturn
   */
  export type PagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Model LogStatus
   */

  export type AggregateLogStatus = {
    _count: LogStatusCountAggregateOutputType | null
    _avg: LogStatusAvgAggregateOutputType | null
    _sum: LogStatusSumAggregateOutputType | null
    _min: LogStatusMinAggregateOutputType | null
    _max: LogStatusMaxAggregateOutputType | null
  }

  export type LogStatusAvgAggregateOutputType = {
    id: number | null
    entidadeId: number | null
    usuarioId: number | null
  }

  export type LogStatusSumAggregateOutputType = {
    id: number | null
    entidadeId: number | null
    usuarioId: number | null
  }

  export type LogStatusMinAggregateOutputType = {
    id: number | null
    entidade: string | null
    entidadeId: number | null
    status: string | null
    usuarioId: number | null
    criadoEm: Date | null
  }

  export type LogStatusMaxAggregateOutputType = {
    id: number | null
    entidade: string | null
    entidadeId: number | null
    status: string | null
    usuarioId: number | null
    criadoEm: Date | null
  }

  export type LogStatusCountAggregateOutputType = {
    id: number
    entidade: number
    entidadeId: number
    status: number
    usuarioId: number
    criadoEm: number
    _all: number
  }


  export type LogStatusAvgAggregateInputType = {
    id?: true
    entidadeId?: true
    usuarioId?: true
  }

  export type LogStatusSumAggregateInputType = {
    id?: true
    entidadeId?: true
    usuarioId?: true
  }

  export type LogStatusMinAggregateInputType = {
    id?: true
    entidade?: true
    entidadeId?: true
    status?: true
    usuarioId?: true
    criadoEm?: true
  }

  export type LogStatusMaxAggregateInputType = {
    id?: true
    entidade?: true
    entidadeId?: true
    status?: true
    usuarioId?: true
    criadoEm?: true
  }

  export type LogStatusCountAggregateInputType = {
    id?: true
    entidade?: true
    entidadeId?: true
    status?: true
    usuarioId?: true
    criadoEm?: true
    _all?: true
  }

  export type LogStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogStatus to aggregate.
     */
    where?: LogStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStatuses to fetch.
     */
    orderBy?: LogStatusOrderByWithRelationInput | LogStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogStatuses
    **/
    _count?: true | LogStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogStatusMaxAggregateInputType
  }

  export type GetLogStatusAggregateType<T extends LogStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateLogStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogStatus[P]>
      : GetScalarType<T[P], AggregateLogStatus[P]>
  }




  export type LogStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogStatusWhereInput
    orderBy?: LogStatusOrderByWithAggregationInput | LogStatusOrderByWithAggregationInput[]
    by: LogStatusScalarFieldEnum[] | LogStatusScalarFieldEnum
    having?: LogStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogStatusCountAggregateInputType | true
    _avg?: LogStatusAvgAggregateInputType
    _sum?: LogStatusSumAggregateInputType
    _min?: LogStatusMinAggregateInputType
    _max?: LogStatusMaxAggregateInputType
  }

  export type LogStatusGroupByOutputType = {
    id: number
    entidade: string
    entidadeId: number
    status: string
    usuarioId: number | null
    criadoEm: Date
    _count: LogStatusCountAggregateOutputType | null
    _avg: LogStatusAvgAggregateOutputType | null
    _sum: LogStatusSumAggregateOutputType | null
    _min: LogStatusMinAggregateOutputType | null
    _max: LogStatusMaxAggregateOutputType | null
  }

  type GetLogStatusGroupByPayload<T extends LogStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogStatusGroupByOutputType[P]>
            : GetScalarType<T[P], LogStatusGroupByOutputType[P]>
        }
      >
    >


  export type LogStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entidade?: boolean
    entidadeId?: boolean
    status?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
    usuario?: boolean | LogStatus$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["logStatus"]>

  export type LogStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entidade?: boolean
    entidadeId?: boolean
    status?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
    usuario?: boolean | LogStatus$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["logStatus"]>

  export type LogStatusSelectScalar = {
    id?: boolean
    entidade?: boolean
    entidadeId?: boolean
    status?: boolean
    usuarioId?: boolean
    criadoEm?: boolean
  }

  export type LogStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | LogStatus$usuarioArgs<ExtArgs>
  }
  export type LogStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | LogStatus$usuarioArgs<ExtArgs>
  }

  export type $LogStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogStatus"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entidade: string
      entidadeId: number
      status: string
      usuarioId: number | null
      criadoEm: Date
    }, ExtArgs["result"]["logStatus"]>
    composites: {}
  }

  type LogStatusGetPayload<S extends boolean | null | undefined | LogStatusDefaultArgs> = $Result.GetResult<Prisma.$LogStatusPayload, S>

  type LogStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogStatusCountAggregateInputType | true
    }

  export interface LogStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogStatus'], meta: { name: 'LogStatus' } }
    /**
     * Find zero or one LogStatus that matches the filter.
     * @param {LogStatusFindUniqueArgs} args - Arguments to find a LogStatus
     * @example
     * // Get one LogStatus
     * const logStatus = await prisma.logStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogStatusFindUniqueArgs>(args: SelectSubset<T, LogStatusFindUniqueArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogStatusFindUniqueOrThrowArgs} args - Arguments to find a LogStatus
     * @example
     * // Get one LogStatus
     * const logStatus = await prisma.logStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, LogStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusFindFirstArgs} args - Arguments to find a LogStatus
     * @example
     * // Get one LogStatus
     * const logStatus = await prisma.logStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogStatusFindFirstArgs>(args?: SelectSubset<T, LogStatusFindFirstArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusFindFirstOrThrowArgs} args - Arguments to find a LogStatus
     * @example
     * // Get one LogStatus
     * const logStatus = await prisma.logStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, LogStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogStatuses
     * const logStatuses = await prisma.logStatus.findMany()
     * 
     * // Get first 10 LogStatuses
     * const logStatuses = await prisma.logStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logStatusWithIdOnly = await prisma.logStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogStatusFindManyArgs>(args?: SelectSubset<T, LogStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogStatus.
     * @param {LogStatusCreateArgs} args - Arguments to create a LogStatus.
     * @example
     * // Create one LogStatus
     * const LogStatus = await prisma.logStatus.create({
     *   data: {
     *     // ... data to create a LogStatus
     *   }
     * })
     * 
     */
    create<T extends LogStatusCreateArgs>(args: SelectSubset<T, LogStatusCreateArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogStatuses.
     * @param {LogStatusCreateManyArgs} args - Arguments to create many LogStatuses.
     * @example
     * // Create many LogStatuses
     * const logStatus = await prisma.logStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogStatusCreateManyArgs>(args?: SelectSubset<T, LogStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogStatuses and returns the data saved in the database.
     * @param {LogStatusCreateManyAndReturnArgs} args - Arguments to create many LogStatuses.
     * @example
     * // Create many LogStatuses
     * const logStatus = await prisma.logStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogStatuses and only return the `id`
     * const logStatusWithIdOnly = await prisma.logStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, LogStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogStatus.
     * @param {LogStatusDeleteArgs} args - Arguments to delete one LogStatus.
     * @example
     * // Delete one LogStatus
     * const LogStatus = await prisma.logStatus.delete({
     *   where: {
     *     // ... filter to delete one LogStatus
     *   }
     * })
     * 
     */
    delete<T extends LogStatusDeleteArgs>(args: SelectSubset<T, LogStatusDeleteArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogStatus.
     * @param {LogStatusUpdateArgs} args - Arguments to update one LogStatus.
     * @example
     * // Update one LogStatus
     * const logStatus = await prisma.logStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogStatusUpdateArgs>(args: SelectSubset<T, LogStatusUpdateArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogStatuses.
     * @param {LogStatusDeleteManyArgs} args - Arguments to filter LogStatuses to delete.
     * @example
     * // Delete a few LogStatuses
     * const { count } = await prisma.logStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogStatusDeleteManyArgs>(args?: SelectSubset<T, LogStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogStatuses
     * const logStatus = await prisma.logStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogStatusUpdateManyArgs>(args: SelectSubset<T, LogStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogStatus.
     * @param {LogStatusUpsertArgs} args - Arguments to update or create a LogStatus.
     * @example
     * // Update or create a LogStatus
     * const logStatus = await prisma.logStatus.upsert({
     *   create: {
     *     // ... data to create a LogStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogStatus we want to update
     *   }
     * })
     */
    upsert<T extends LogStatusUpsertArgs>(args: SelectSubset<T, LogStatusUpsertArgs<ExtArgs>>): Prisma__LogStatusClient<$Result.GetResult<Prisma.$LogStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusCountArgs} args - Arguments to filter LogStatuses to count.
     * @example
     * // Count the number of LogStatuses
     * const count = await prisma.logStatus.count({
     *   where: {
     *     // ... the filter for the LogStatuses we want to count
     *   }
     * })
    **/
    count<T extends LogStatusCountArgs>(
      args?: Subset<T, LogStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogStatusAggregateArgs>(args: Subset<T, LogStatusAggregateArgs>): Prisma.PrismaPromise<GetLogStatusAggregateType<T>>

    /**
     * Group by LogStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogStatusGroupByArgs['orderBy'] }
        : { orderBy?: LogStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogStatus model
   */
  readonly fields: LogStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends LogStatus$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, LogStatus$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogStatus model
   */ 
  interface LogStatusFieldRefs {
    readonly id: FieldRef<"LogStatus", 'Int'>
    readonly entidade: FieldRef<"LogStatus", 'String'>
    readonly entidadeId: FieldRef<"LogStatus", 'Int'>
    readonly status: FieldRef<"LogStatus", 'String'>
    readonly usuarioId: FieldRef<"LogStatus", 'Int'>
    readonly criadoEm: FieldRef<"LogStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogStatus findUnique
   */
  export type LogStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter, which LogStatus to fetch.
     */
    where: LogStatusWhereUniqueInput
  }

  /**
   * LogStatus findUniqueOrThrow
   */
  export type LogStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter, which LogStatus to fetch.
     */
    where: LogStatusWhereUniqueInput
  }

  /**
   * LogStatus findFirst
   */
  export type LogStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter, which LogStatus to fetch.
     */
    where?: LogStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStatuses to fetch.
     */
    orderBy?: LogStatusOrderByWithRelationInput | LogStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogStatuses.
     */
    cursor?: LogStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogStatuses.
     */
    distinct?: LogStatusScalarFieldEnum | LogStatusScalarFieldEnum[]
  }

  /**
   * LogStatus findFirstOrThrow
   */
  export type LogStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter, which LogStatus to fetch.
     */
    where?: LogStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStatuses to fetch.
     */
    orderBy?: LogStatusOrderByWithRelationInput | LogStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogStatuses.
     */
    cursor?: LogStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogStatuses.
     */
    distinct?: LogStatusScalarFieldEnum | LogStatusScalarFieldEnum[]
  }

  /**
   * LogStatus findMany
   */
  export type LogStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter, which LogStatuses to fetch.
     */
    where?: LogStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogStatuses to fetch.
     */
    orderBy?: LogStatusOrderByWithRelationInput | LogStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogStatuses.
     */
    cursor?: LogStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogStatuses.
     */
    skip?: number
    distinct?: LogStatusScalarFieldEnum | LogStatusScalarFieldEnum[]
  }

  /**
   * LogStatus create
   */
  export type LogStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a LogStatus.
     */
    data: XOR<LogStatusCreateInput, LogStatusUncheckedCreateInput>
  }

  /**
   * LogStatus createMany
   */
  export type LogStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogStatuses.
     */
    data: LogStatusCreateManyInput | LogStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogStatus createManyAndReturn
   */
  export type LogStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogStatuses.
     */
    data: LogStatusCreateManyInput | LogStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogStatus update
   */
  export type LogStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a LogStatus.
     */
    data: XOR<LogStatusUpdateInput, LogStatusUncheckedUpdateInput>
    /**
     * Choose, which LogStatus to update.
     */
    where: LogStatusWhereUniqueInput
  }

  /**
   * LogStatus updateMany
   */
  export type LogStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogStatuses.
     */
    data: XOR<LogStatusUpdateManyMutationInput, LogStatusUncheckedUpdateManyInput>
    /**
     * Filter which LogStatuses to update
     */
    where?: LogStatusWhereInput
  }

  /**
   * LogStatus upsert
   */
  export type LogStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the LogStatus to update in case it exists.
     */
    where: LogStatusWhereUniqueInput
    /**
     * In case the LogStatus found by the `where` argument doesn't exist, create a new LogStatus with this data.
     */
    create: XOR<LogStatusCreateInput, LogStatusUncheckedCreateInput>
    /**
     * In case the LogStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogStatusUpdateInput, LogStatusUncheckedUpdateInput>
  }

  /**
   * LogStatus delete
   */
  export type LogStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
    /**
     * Filter which LogStatus to delete.
     */
    where: LogStatusWhereUniqueInput
  }

  /**
   * LogStatus deleteMany
   */
  export type LogStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogStatuses to delete
     */
    where?: LogStatusWhereInput
  }

  /**
   * LogStatus.usuario
   */
  export type LogStatus$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * LogStatus without action
   */
  export type LogStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogStatus
     */
    select?: LogStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogStatusInclude<ExtArgs> | null
  }


  /**
   * Model PrinterConfig
   */

  export type AggregatePrinterConfig = {
    _count: PrinterConfigCountAggregateOutputType | null
    _avg: PrinterConfigAvgAggregateOutputType | null
    _sum: PrinterConfigSumAggregateOutputType | null
    _min: PrinterConfigMinAggregateOutputType | null
    _max: PrinterConfigMaxAggregateOutputType | null
  }

  export type PrinterConfigAvgAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type PrinterConfigSumAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type PrinterConfigMinAggregateOutputType = {
    id: number | null
    setor: string | null
    name: string | null
    ip: string | null
    port: number | null
    enabled: boolean | null
  }

  export type PrinterConfigMaxAggregateOutputType = {
    id: number | null
    setor: string | null
    name: string | null
    ip: string | null
    port: number | null
    enabled: boolean | null
  }

  export type PrinterConfigCountAggregateOutputType = {
    id: number
    setor: number
    name: number
    ip: number
    port: number
    enabled: number
    _all: number
  }


  export type PrinterConfigAvgAggregateInputType = {
    id?: true
    port?: true
  }

  export type PrinterConfigSumAggregateInputType = {
    id?: true
    port?: true
  }

  export type PrinterConfigMinAggregateInputType = {
    id?: true
    setor?: true
    name?: true
    ip?: true
    port?: true
    enabled?: true
  }

  export type PrinterConfigMaxAggregateInputType = {
    id?: true
    setor?: true
    name?: true
    ip?: true
    port?: true
    enabled?: true
  }

  export type PrinterConfigCountAggregateInputType = {
    id?: true
    setor?: true
    name?: true
    ip?: true
    port?: true
    enabled?: true
    _all?: true
  }

  export type PrinterConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrinterConfig to aggregate.
     */
    where?: PrinterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrinterConfigs to fetch.
     */
    orderBy?: PrinterConfigOrderByWithRelationInput | PrinterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrinterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrinterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrinterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrinterConfigs
    **/
    _count?: true | PrinterConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrinterConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrinterConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrinterConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrinterConfigMaxAggregateInputType
  }

  export type GetPrinterConfigAggregateType<T extends PrinterConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePrinterConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrinterConfig[P]>
      : GetScalarType<T[P], AggregatePrinterConfig[P]>
  }




  export type PrinterConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrinterConfigWhereInput
    orderBy?: PrinterConfigOrderByWithAggregationInput | PrinterConfigOrderByWithAggregationInput[]
    by: PrinterConfigScalarFieldEnum[] | PrinterConfigScalarFieldEnum
    having?: PrinterConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrinterConfigCountAggregateInputType | true
    _avg?: PrinterConfigAvgAggregateInputType
    _sum?: PrinterConfigSumAggregateInputType
    _min?: PrinterConfigMinAggregateInputType
    _max?: PrinterConfigMaxAggregateInputType
  }

  export type PrinterConfigGroupByOutputType = {
    id: number
    setor: string
    name: string
    ip: string
    port: number
    enabled: boolean
    _count: PrinterConfigCountAggregateOutputType | null
    _avg: PrinterConfigAvgAggregateOutputType | null
    _sum: PrinterConfigSumAggregateOutputType | null
    _min: PrinterConfigMinAggregateOutputType | null
    _max: PrinterConfigMaxAggregateOutputType | null
  }

  type GetPrinterConfigGroupByPayload<T extends PrinterConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrinterConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrinterConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrinterConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PrinterConfigGroupByOutputType[P]>
        }
      >
    >


  export type PrinterConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setor?: boolean
    name?: boolean
    ip?: boolean
    port?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["printerConfig"]>

  export type PrinterConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    setor?: boolean
    name?: boolean
    ip?: boolean
    port?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["printerConfig"]>

  export type PrinterConfigSelectScalar = {
    id?: boolean
    setor?: boolean
    name?: boolean
    ip?: boolean
    port?: boolean
    enabled?: boolean
  }


  export type $PrinterConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrinterConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      setor: string
      name: string
      ip: string
      port: number
      enabled: boolean
    }, ExtArgs["result"]["printerConfig"]>
    composites: {}
  }

  type PrinterConfigGetPayload<S extends boolean | null | undefined | PrinterConfigDefaultArgs> = $Result.GetResult<Prisma.$PrinterConfigPayload, S>

  type PrinterConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrinterConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrinterConfigCountAggregateInputType | true
    }

  export interface PrinterConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrinterConfig'], meta: { name: 'PrinterConfig' } }
    /**
     * Find zero or one PrinterConfig that matches the filter.
     * @param {PrinterConfigFindUniqueArgs} args - Arguments to find a PrinterConfig
     * @example
     * // Get one PrinterConfig
     * const printerConfig = await prisma.printerConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrinterConfigFindUniqueArgs>(args: SelectSubset<T, PrinterConfigFindUniqueArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrinterConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrinterConfigFindUniqueOrThrowArgs} args - Arguments to find a PrinterConfig
     * @example
     * // Get one PrinterConfig
     * const printerConfig = await prisma.printerConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrinterConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PrinterConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrinterConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigFindFirstArgs} args - Arguments to find a PrinterConfig
     * @example
     * // Get one PrinterConfig
     * const printerConfig = await prisma.printerConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrinterConfigFindFirstArgs>(args?: SelectSubset<T, PrinterConfigFindFirstArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrinterConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigFindFirstOrThrowArgs} args - Arguments to find a PrinterConfig
     * @example
     * // Get one PrinterConfig
     * const printerConfig = await prisma.printerConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrinterConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PrinterConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrinterConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrinterConfigs
     * const printerConfigs = await prisma.printerConfig.findMany()
     * 
     * // Get first 10 PrinterConfigs
     * const printerConfigs = await prisma.printerConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printerConfigWithIdOnly = await prisma.printerConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrinterConfigFindManyArgs>(args?: SelectSubset<T, PrinterConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrinterConfig.
     * @param {PrinterConfigCreateArgs} args - Arguments to create a PrinterConfig.
     * @example
     * // Create one PrinterConfig
     * const PrinterConfig = await prisma.printerConfig.create({
     *   data: {
     *     // ... data to create a PrinterConfig
     *   }
     * })
     * 
     */
    create<T extends PrinterConfigCreateArgs>(args: SelectSubset<T, PrinterConfigCreateArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrinterConfigs.
     * @param {PrinterConfigCreateManyArgs} args - Arguments to create many PrinterConfigs.
     * @example
     * // Create many PrinterConfigs
     * const printerConfig = await prisma.printerConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrinterConfigCreateManyArgs>(args?: SelectSubset<T, PrinterConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrinterConfigs and returns the data saved in the database.
     * @param {PrinterConfigCreateManyAndReturnArgs} args - Arguments to create many PrinterConfigs.
     * @example
     * // Create many PrinterConfigs
     * const printerConfig = await prisma.printerConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrinterConfigs and only return the `id`
     * const printerConfigWithIdOnly = await prisma.printerConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrinterConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PrinterConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrinterConfig.
     * @param {PrinterConfigDeleteArgs} args - Arguments to delete one PrinterConfig.
     * @example
     * // Delete one PrinterConfig
     * const PrinterConfig = await prisma.printerConfig.delete({
     *   where: {
     *     // ... filter to delete one PrinterConfig
     *   }
     * })
     * 
     */
    delete<T extends PrinterConfigDeleteArgs>(args: SelectSubset<T, PrinterConfigDeleteArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrinterConfig.
     * @param {PrinterConfigUpdateArgs} args - Arguments to update one PrinterConfig.
     * @example
     * // Update one PrinterConfig
     * const printerConfig = await prisma.printerConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrinterConfigUpdateArgs>(args: SelectSubset<T, PrinterConfigUpdateArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrinterConfigs.
     * @param {PrinterConfigDeleteManyArgs} args - Arguments to filter PrinterConfigs to delete.
     * @example
     * // Delete a few PrinterConfigs
     * const { count } = await prisma.printerConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrinterConfigDeleteManyArgs>(args?: SelectSubset<T, PrinterConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrinterConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrinterConfigs
     * const printerConfig = await prisma.printerConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrinterConfigUpdateManyArgs>(args: SelectSubset<T, PrinterConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrinterConfig.
     * @param {PrinterConfigUpsertArgs} args - Arguments to update or create a PrinterConfig.
     * @example
     * // Update or create a PrinterConfig
     * const printerConfig = await prisma.printerConfig.upsert({
     *   create: {
     *     // ... data to create a PrinterConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrinterConfig we want to update
     *   }
     * })
     */
    upsert<T extends PrinterConfigUpsertArgs>(args: SelectSubset<T, PrinterConfigUpsertArgs<ExtArgs>>): Prisma__PrinterConfigClient<$Result.GetResult<Prisma.$PrinterConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrinterConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigCountArgs} args - Arguments to filter PrinterConfigs to count.
     * @example
     * // Count the number of PrinterConfigs
     * const count = await prisma.printerConfig.count({
     *   where: {
     *     // ... the filter for the PrinterConfigs we want to count
     *   }
     * })
    **/
    count<T extends PrinterConfigCountArgs>(
      args?: Subset<T, PrinterConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrinterConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrinterConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrinterConfigAggregateArgs>(args: Subset<T, PrinterConfigAggregateArgs>): Prisma.PrismaPromise<GetPrinterConfigAggregateType<T>>

    /**
     * Group by PrinterConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrinterConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrinterConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrinterConfigGroupByArgs['orderBy'] }
        : { orderBy?: PrinterConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrinterConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrinterConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrinterConfig model
   */
  readonly fields: PrinterConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrinterConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrinterConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrinterConfig model
   */ 
  interface PrinterConfigFieldRefs {
    readonly id: FieldRef<"PrinterConfig", 'Int'>
    readonly setor: FieldRef<"PrinterConfig", 'String'>
    readonly name: FieldRef<"PrinterConfig", 'String'>
    readonly ip: FieldRef<"PrinterConfig", 'String'>
    readonly port: FieldRef<"PrinterConfig", 'Int'>
    readonly enabled: FieldRef<"PrinterConfig", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PrinterConfig findUnique
   */
  export type PrinterConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter, which PrinterConfig to fetch.
     */
    where: PrinterConfigWhereUniqueInput
  }

  /**
   * PrinterConfig findUniqueOrThrow
   */
  export type PrinterConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter, which PrinterConfig to fetch.
     */
    where: PrinterConfigWhereUniqueInput
  }

  /**
   * PrinterConfig findFirst
   */
  export type PrinterConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter, which PrinterConfig to fetch.
     */
    where?: PrinterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrinterConfigs to fetch.
     */
    orderBy?: PrinterConfigOrderByWithRelationInput | PrinterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrinterConfigs.
     */
    cursor?: PrinterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrinterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrinterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrinterConfigs.
     */
    distinct?: PrinterConfigScalarFieldEnum | PrinterConfigScalarFieldEnum[]
  }

  /**
   * PrinterConfig findFirstOrThrow
   */
  export type PrinterConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter, which PrinterConfig to fetch.
     */
    where?: PrinterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrinterConfigs to fetch.
     */
    orderBy?: PrinterConfigOrderByWithRelationInput | PrinterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrinterConfigs.
     */
    cursor?: PrinterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrinterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrinterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrinterConfigs.
     */
    distinct?: PrinterConfigScalarFieldEnum | PrinterConfigScalarFieldEnum[]
  }

  /**
   * PrinterConfig findMany
   */
  export type PrinterConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter, which PrinterConfigs to fetch.
     */
    where?: PrinterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrinterConfigs to fetch.
     */
    orderBy?: PrinterConfigOrderByWithRelationInput | PrinterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrinterConfigs.
     */
    cursor?: PrinterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrinterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrinterConfigs.
     */
    skip?: number
    distinct?: PrinterConfigScalarFieldEnum | PrinterConfigScalarFieldEnum[]
  }

  /**
   * PrinterConfig create
   */
  export type PrinterConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a PrinterConfig.
     */
    data: XOR<PrinterConfigCreateInput, PrinterConfigUncheckedCreateInput>
  }

  /**
   * PrinterConfig createMany
   */
  export type PrinterConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrinterConfigs.
     */
    data: PrinterConfigCreateManyInput | PrinterConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrinterConfig createManyAndReturn
   */
  export type PrinterConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrinterConfigs.
     */
    data: PrinterConfigCreateManyInput | PrinterConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrinterConfig update
   */
  export type PrinterConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a PrinterConfig.
     */
    data: XOR<PrinterConfigUpdateInput, PrinterConfigUncheckedUpdateInput>
    /**
     * Choose, which PrinterConfig to update.
     */
    where: PrinterConfigWhereUniqueInput
  }

  /**
   * PrinterConfig updateMany
   */
  export type PrinterConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrinterConfigs.
     */
    data: XOR<PrinterConfigUpdateManyMutationInput, PrinterConfigUncheckedUpdateManyInput>
    /**
     * Filter which PrinterConfigs to update
     */
    where?: PrinterConfigWhereInput
  }

  /**
   * PrinterConfig upsert
   */
  export type PrinterConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the PrinterConfig to update in case it exists.
     */
    where: PrinterConfigWhereUniqueInput
    /**
     * In case the PrinterConfig found by the `where` argument doesn't exist, create a new PrinterConfig with this data.
     */
    create: XOR<PrinterConfigCreateInput, PrinterConfigUncheckedCreateInput>
    /**
     * In case the PrinterConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrinterConfigUpdateInput, PrinterConfigUncheckedUpdateInput>
  }

  /**
   * PrinterConfig delete
   */
  export type PrinterConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
    /**
     * Filter which PrinterConfig to delete.
     */
    where: PrinterConfigWhereUniqueInput
  }

  /**
   * PrinterConfig deleteMany
   */
  export type PrinterConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrinterConfigs to delete
     */
    where?: PrinterConfigWhereInput
  }

  /**
   * PrinterConfig without action
   */
  export type PrinterConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrinterConfig
     */
    select?: PrinterConfigSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MesaScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    status: 'status'
  };

  export type MesaScalarFieldEnum = (typeof MesaScalarFieldEnum)[keyof typeof MesaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    login: 'login',
    role: 'role',
    senha: 'senha'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ComandaScalarFieldEnum: {
    id: 'id',
    mesaId: 'mesaId',
    usuarioId: 'usuarioId',
    status: 'status',
    total: 'total',
    abertaEm: 'abertaEm',
    fechadaEm: 'fechadaEm'
  };

  export type ComandaScalarFieldEnum = (typeof ComandaScalarFieldEnum)[keyof typeof ComandaScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    comandaId: 'comandaId',
    garcomId: 'garcomId',
    status: 'status',
    criadoEm: 'criadoEm'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    setor: 'setor'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const ProdutoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    categoriaId: 'categoriaId',
    preco: 'preco',
    ativo: 'ativo',
    foto: 'foto',
    tipoOpcao: 'tipoOpcao',
    sabores: 'sabores',
    isDrink: 'isDrink',
    isFood: 'isFood',
    permitirObservacao: 'permitirObservacao',
    permiteGeloLimao: 'permiteGeloLimao',
    favorito: 'favorito',
    ultimoUso: 'ultimoUso',
    estoque: 'estoque',
    esgotado: 'esgotado'
  };

  export type ProdutoScalarFieldEnum = (typeof ProdutoScalarFieldEnum)[keyof typeof ProdutoScalarFieldEnum]


  export const PedidoItemScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    produtoId: 'produtoId',
    quantidade: 'quantidade',
    observacao: 'observacao',
    status: 'status'
  };

  export type PedidoItemScalarFieldEnum = (typeof PedidoItemScalarFieldEnum)[keyof typeof PedidoItemScalarFieldEnum]


  export const OrdemProducaoScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    setor: 'setor',
    status: 'status',
    criadaEm: 'criadaEm',
    finalizadaEm: 'finalizadaEm'
  };

  export type OrdemProducaoScalarFieldEnum = (typeof OrdemProducaoScalarFieldEnum)[keyof typeof OrdemProducaoScalarFieldEnum]


  export const OrdemItemScalarFieldEnum: {
    id: 'id',
    ordemProducaoId: 'ordemProducaoId',
    pedidoItemId: 'pedidoItemId'
  };

  export type OrdemItemScalarFieldEnum = (typeof OrdemItemScalarFieldEnum)[keyof typeof OrdemItemScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    comandaId: 'comandaId',
    tipo: 'tipo',
    valor: 'valor',
    status: 'status',
    criadoEm: 'criadoEm'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const LogStatusScalarFieldEnum: {
    id: 'id',
    entidade: 'entidade',
    entidadeId: 'entidadeId',
    status: 'status',
    usuarioId: 'usuarioId',
    criadoEm: 'criadoEm'
  };

  export type LogStatusScalarFieldEnum = (typeof LogStatusScalarFieldEnum)[keyof typeof LogStatusScalarFieldEnum]


  export const PrinterConfigScalarFieldEnum: {
    id: 'id',
    setor: 'setor',
    name: 'name',
    ip: 'ip',
    port: 'port',
    enabled: 'enabled'
  };

  export type PrinterConfigScalarFieldEnum = (typeof PrinterConfigScalarFieldEnum)[keyof typeof PrinterConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type MesaWhereInput = {
    AND?: MesaWhereInput | MesaWhereInput[]
    OR?: MesaWhereInput[]
    NOT?: MesaWhereInput | MesaWhereInput[]
    id?: IntFilter<"Mesa"> | number
    numero?: IntFilter<"Mesa"> | number
    status?: StringFilter<"Mesa"> | string
    comandas?: ComandaListRelationFilter
  }

  export type MesaOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    status?: SortOrder
    comandas?: ComandaOrderByRelationAggregateInput
  }

  export type MesaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numero?: number
    AND?: MesaWhereInput | MesaWhereInput[]
    OR?: MesaWhereInput[]
    NOT?: MesaWhereInput | MesaWhereInput[]
    status?: StringFilter<"Mesa"> | string
    comandas?: ComandaListRelationFilter
  }, "id" | "numero">

  export type MesaOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    status?: SortOrder
    _count?: MesaCountOrderByAggregateInput
    _avg?: MesaAvgOrderByAggregateInput
    _max?: MesaMaxOrderByAggregateInput
    _min?: MesaMinOrderByAggregateInput
    _sum?: MesaSumOrderByAggregateInput
  }

  export type MesaScalarWhereWithAggregatesInput = {
    AND?: MesaScalarWhereWithAggregatesInput | MesaScalarWhereWithAggregatesInput[]
    OR?: MesaScalarWhereWithAggregatesInput[]
    NOT?: MesaScalarWhereWithAggregatesInput | MesaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mesa"> | number
    numero?: IntWithAggregatesFilter<"Mesa"> | number
    status?: StringWithAggregatesFilter<"Mesa"> | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nome?: StringFilter<"Usuario"> | string
    login?: StringFilter<"Usuario"> | string
    role?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    pedidos?: PedidoListRelationFilter
    comandas?: ComandaListRelationFilter
    logs?: LogStatusListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    login?: SortOrder
    role?: SortOrder
    senha?: SortOrder
    pedidos?: PedidoOrderByRelationAggregateInput
    comandas?: ComandaOrderByRelationAggregateInput
    logs?: LogStatusOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    login?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    role?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    pedidos?: PedidoListRelationFilter
    comandas?: ComandaListRelationFilter
    logs?: LogStatusListRelationFilter
  }, "id" | "login">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    login?: SortOrder
    role?: SortOrder
    senha?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    login?: StringWithAggregatesFilter<"Usuario"> | string
    role?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
  }

  export type ComandaWhereInput = {
    AND?: ComandaWhereInput | ComandaWhereInput[]
    OR?: ComandaWhereInput[]
    NOT?: ComandaWhereInput | ComandaWhereInput[]
    id?: IntFilter<"Comanda"> | number
    mesaId?: IntFilter<"Comanda"> | number
    usuarioId?: IntNullableFilter<"Comanda"> | number | null
    status?: StringFilter<"Comanda"> | string
    total?: FloatFilter<"Comanda"> | number
    abertaEm?: DateTimeFilter<"Comanda"> | Date | string
    fechadaEm?: DateTimeNullableFilter<"Comanda"> | Date | string | null
    mesa?: XOR<MesaRelationFilter, MesaWhereInput>
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    pedidos?: PedidoListRelationFilter
    pagamentos?: PagamentoListRelationFilter
  }

  export type ComandaOrderByWithRelationInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    abertaEm?: SortOrder
    fechadaEm?: SortOrderInput | SortOrder
    mesa?: MesaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    pedidos?: PedidoOrderByRelationAggregateInput
    pagamentos?: PagamentoOrderByRelationAggregateInput
  }

  export type ComandaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComandaWhereInput | ComandaWhereInput[]
    OR?: ComandaWhereInput[]
    NOT?: ComandaWhereInput | ComandaWhereInput[]
    mesaId?: IntFilter<"Comanda"> | number
    usuarioId?: IntNullableFilter<"Comanda"> | number | null
    status?: StringFilter<"Comanda"> | string
    total?: FloatFilter<"Comanda"> | number
    abertaEm?: DateTimeFilter<"Comanda"> | Date | string
    fechadaEm?: DateTimeNullableFilter<"Comanda"> | Date | string | null
    mesa?: XOR<MesaRelationFilter, MesaWhereInput>
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    pedidos?: PedidoListRelationFilter
    pagamentos?: PagamentoListRelationFilter
  }, "id">

  export type ComandaOrderByWithAggregationInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    abertaEm?: SortOrder
    fechadaEm?: SortOrderInput | SortOrder
    _count?: ComandaCountOrderByAggregateInput
    _avg?: ComandaAvgOrderByAggregateInput
    _max?: ComandaMaxOrderByAggregateInput
    _min?: ComandaMinOrderByAggregateInput
    _sum?: ComandaSumOrderByAggregateInput
  }

  export type ComandaScalarWhereWithAggregatesInput = {
    AND?: ComandaScalarWhereWithAggregatesInput | ComandaScalarWhereWithAggregatesInput[]
    OR?: ComandaScalarWhereWithAggregatesInput[]
    NOT?: ComandaScalarWhereWithAggregatesInput | ComandaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comanda"> | number
    mesaId?: IntWithAggregatesFilter<"Comanda"> | number
    usuarioId?: IntNullableWithAggregatesFilter<"Comanda"> | number | null
    status?: StringWithAggregatesFilter<"Comanda"> | string
    total?: FloatWithAggregatesFilter<"Comanda"> | number
    abertaEm?: DateTimeWithAggregatesFilter<"Comanda"> | Date | string
    fechadaEm?: DateTimeNullableWithAggregatesFilter<"Comanda"> | Date | string | null
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    id?: IntFilter<"Pedido"> | number
    comandaId?: IntFilter<"Pedido"> | number
    garcomId?: IntNullableFilter<"Pedido"> | number | null
    status?: StringFilter<"Pedido"> | string
    criadoEm?: DateTimeFilter<"Pedido"> | Date | string
    comanda?: XOR<ComandaRelationFilter, ComandaWhereInput>
    garcom?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    itens?: PedidoItemListRelationFilter
    ordensProducao?: OrdemProducaoListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrderInput | SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    comanda?: ComandaOrderByWithRelationInput
    garcom?: UsuarioOrderByWithRelationInput
    itens?: PedidoItemOrderByRelationAggregateInput
    ordensProducao?: OrdemProducaoOrderByRelationAggregateInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    comandaId?: IntFilter<"Pedido"> | number
    garcomId?: IntNullableFilter<"Pedido"> | number | null
    status?: StringFilter<"Pedido"> | string
    criadoEm?: DateTimeFilter<"Pedido"> | Date | string
    comanda?: XOR<ComandaRelationFilter, ComandaWhereInput>
    garcom?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    itens?: PedidoItemListRelationFilter
    ordensProducao?: OrdemProducaoListRelationFilter
  }, "id">

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrderInput | SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pedido"> | number
    comandaId?: IntWithAggregatesFilter<"Pedido"> | number
    garcomId?: IntNullableWithAggregatesFilter<"Pedido"> | number | null
    status?: StringWithAggregatesFilter<"Pedido"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nome?: StringFilter<"Categoria"> | string
    setor?: StringFilter<"Categoria"> | string
    produtos?: ProdutoListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    setor?: SortOrder
    produtos?: ProdutoOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nome?: StringFilter<"Categoria"> | string
    setor?: StringFilter<"Categoria"> | string
    produtos?: ProdutoListRelationFilter
  }, "id">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    setor?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nome?: StringWithAggregatesFilter<"Categoria"> | string
    setor?: StringWithAggregatesFilter<"Categoria"> | string
  }

  export type ProdutoWhereInput = {
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    id?: IntFilter<"Produto"> | number
    nome?: StringFilter<"Produto"> | string
    categoriaId?: IntNullableFilter<"Produto"> | number | null
    preco?: FloatFilter<"Produto"> | number
    ativo?: BoolFilter<"Produto"> | boolean
    foto?: StringNullableFilter<"Produto"> | string | null
    tipoOpcao?: StringFilter<"Produto"> | string
    sabores?: StringNullableFilter<"Produto"> | string | null
    isDrink?: BoolFilter<"Produto"> | boolean
    isFood?: BoolFilter<"Produto"> | boolean
    permitirObservacao?: BoolFilter<"Produto"> | boolean
    permiteGeloLimao?: BoolFilter<"Produto"> | boolean
    favorito?: BoolFilter<"Produto"> | boolean
    ultimoUso?: DateTimeNullableFilter<"Produto"> | Date | string | null
    estoque?: IntNullableFilter<"Produto"> | number | null
    esgotado?: BoolFilter<"Produto"> | boolean
    categoria?: XOR<CategoriaNullableRelationFilter, CategoriaWhereInput> | null
    itens?: PedidoItemListRelationFilter
  }

  export type ProdutoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    categoriaId?: SortOrderInput | SortOrder
    preco?: SortOrder
    ativo?: SortOrder
    foto?: SortOrderInput | SortOrder
    tipoOpcao?: SortOrder
    sabores?: SortOrderInput | SortOrder
    isDrink?: SortOrder
    isFood?: SortOrder
    permitirObservacao?: SortOrder
    permiteGeloLimao?: SortOrder
    favorito?: SortOrder
    ultimoUso?: SortOrderInput | SortOrder
    estoque?: SortOrderInput | SortOrder
    esgotado?: SortOrder
    categoria?: CategoriaOrderByWithRelationInput
    itens?: PedidoItemOrderByRelationAggregateInput
  }

  export type ProdutoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    nome?: StringFilter<"Produto"> | string
    categoriaId?: IntNullableFilter<"Produto"> | number | null
    preco?: FloatFilter<"Produto"> | number
    ativo?: BoolFilter<"Produto"> | boolean
    foto?: StringNullableFilter<"Produto"> | string | null
    tipoOpcao?: StringFilter<"Produto"> | string
    sabores?: StringNullableFilter<"Produto"> | string | null
    isDrink?: BoolFilter<"Produto"> | boolean
    isFood?: BoolFilter<"Produto"> | boolean
    permitirObservacao?: BoolFilter<"Produto"> | boolean
    permiteGeloLimao?: BoolFilter<"Produto"> | boolean
    favorito?: BoolFilter<"Produto"> | boolean
    ultimoUso?: DateTimeNullableFilter<"Produto"> | Date | string | null
    estoque?: IntNullableFilter<"Produto"> | number | null
    esgotado?: BoolFilter<"Produto"> | boolean
    categoria?: XOR<CategoriaNullableRelationFilter, CategoriaWhereInput> | null
    itens?: PedidoItemListRelationFilter
  }, "id">

  export type ProdutoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    categoriaId?: SortOrderInput | SortOrder
    preco?: SortOrder
    ativo?: SortOrder
    foto?: SortOrderInput | SortOrder
    tipoOpcao?: SortOrder
    sabores?: SortOrderInput | SortOrder
    isDrink?: SortOrder
    isFood?: SortOrder
    permitirObservacao?: SortOrder
    permiteGeloLimao?: SortOrder
    favorito?: SortOrder
    ultimoUso?: SortOrderInput | SortOrder
    estoque?: SortOrderInput | SortOrder
    esgotado?: SortOrder
    _count?: ProdutoCountOrderByAggregateInput
    _avg?: ProdutoAvgOrderByAggregateInput
    _max?: ProdutoMaxOrderByAggregateInput
    _min?: ProdutoMinOrderByAggregateInput
    _sum?: ProdutoSumOrderByAggregateInput
  }

  export type ProdutoScalarWhereWithAggregatesInput = {
    AND?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    OR?: ProdutoScalarWhereWithAggregatesInput[]
    NOT?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produto"> | number
    nome?: StringWithAggregatesFilter<"Produto"> | string
    categoriaId?: IntNullableWithAggregatesFilter<"Produto"> | number | null
    preco?: FloatWithAggregatesFilter<"Produto"> | number
    ativo?: BoolWithAggregatesFilter<"Produto"> | boolean
    foto?: StringNullableWithAggregatesFilter<"Produto"> | string | null
    tipoOpcao?: StringWithAggregatesFilter<"Produto"> | string
    sabores?: StringNullableWithAggregatesFilter<"Produto"> | string | null
    isDrink?: BoolWithAggregatesFilter<"Produto"> | boolean
    isFood?: BoolWithAggregatesFilter<"Produto"> | boolean
    permitirObservacao?: BoolWithAggregatesFilter<"Produto"> | boolean
    permiteGeloLimao?: BoolWithAggregatesFilter<"Produto"> | boolean
    favorito?: BoolWithAggregatesFilter<"Produto"> | boolean
    ultimoUso?: DateTimeNullableWithAggregatesFilter<"Produto"> | Date | string | null
    estoque?: IntNullableWithAggregatesFilter<"Produto"> | number | null
    esgotado?: BoolWithAggregatesFilter<"Produto"> | boolean
  }

  export type PedidoItemWhereInput = {
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    id?: IntFilter<"PedidoItem"> | number
    pedidoId?: IntFilter<"PedidoItem"> | number
    produtoId?: IntFilter<"PedidoItem"> | number
    quantidade?: IntFilter<"PedidoItem"> | number
    observacao?: StringNullableFilter<"PedidoItem"> | string | null
    status?: StringFilter<"PedidoItem"> | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    ordemItens?: OrdemItemListRelationFilter
  }

  export type PedidoItemOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
    observacao?: SortOrderInput | SortOrder
    status?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    produto?: ProdutoOrderByWithRelationInput
    ordemItens?: OrdemItemOrderByRelationAggregateInput
  }

  export type PedidoItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    pedidoId?: IntFilter<"PedidoItem"> | number
    produtoId?: IntFilter<"PedidoItem"> | number
    quantidade?: IntFilter<"PedidoItem"> | number
    observacao?: StringNullableFilter<"PedidoItem"> | string | null
    status?: StringFilter<"PedidoItem"> | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    produto?: XOR<ProdutoRelationFilter, ProdutoWhereInput>
    ordemItens?: OrdemItemListRelationFilter
  }, "id">

  export type PedidoItemOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
    observacao?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: PedidoItemCountOrderByAggregateInput
    _avg?: PedidoItemAvgOrderByAggregateInput
    _max?: PedidoItemMaxOrderByAggregateInput
    _min?: PedidoItemMinOrderByAggregateInput
    _sum?: PedidoItemSumOrderByAggregateInput
  }

  export type PedidoItemScalarWhereWithAggregatesInput = {
    AND?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    OR?: PedidoItemScalarWhereWithAggregatesInput[]
    NOT?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PedidoItem"> | number
    pedidoId?: IntWithAggregatesFilter<"PedidoItem"> | number
    produtoId?: IntWithAggregatesFilter<"PedidoItem"> | number
    quantidade?: IntWithAggregatesFilter<"PedidoItem"> | number
    observacao?: StringNullableWithAggregatesFilter<"PedidoItem"> | string | null
    status?: StringWithAggregatesFilter<"PedidoItem"> | string
  }

  export type OrdemProducaoWhereInput = {
    AND?: OrdemProducaoWhereInput | OrdemProducaoWhereInput[]
    OR?: OrdemProducaoWhereInput[]
    NOT?: OrdemProducaoWhereInput | OrdemProducaoWhereInput[]
    id?: IntFilter<"OrdemProducao"> | number
    pedidoId?: IntFilter<"OrdemProducao"> | number
    setor?: StringFilter<"OrdemProducao"> | string
    status?: StringFilter<"OrdemProducao"> | string
    criadaEm?: DateTimeFilter<"OrdemProducao"> | Date | string
    finalizadaEm?: DateTimeNullableFilter<"OrdemProducao"> | Date | string | null
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    itens?: OrdemItemListRelationFilter
  }

  export type OrdemProducaoOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    setor?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
    finalizadaEm?: SortOrderInput | SortOrder
    pedido?: PedidoOrderByWithRelationInput
    itens?: OrdemItemOrderByRelationAggregateInput
  }

  export type OrdemProducaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrdemProducaoWhereInput | OrdemProducaoWhereInput[]
    OR?: OrdemProducaoWhereInput[]
    NOT?: OrdemProducaoWhereInput | OrdemProducaoWhereInput[]
    pedidoId?: IntFilter<"OrdemProducao"> | number
    setor?: StringFilter<"OrdemProducao"> | string
    status?: StringFilter<"OrdemProducao"> | string
    criadaEm?: DateTimeFilter<"OrdemProducao"> | Date | string
    finalizadaEm?: DateTimeNullableFilter<"OrdemProducao"> | Date | string | null
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    itens?: OrdemItemListRelationFilter
  }, "id">

  export type OrdemProducaoOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    setor?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
    finalizadaEm?: SortOrderInput | SortOrder
    _count?: OrdemProducaoCountOrderByAggregateInput
    _avg?: OrdemProducaoAvgOrderByAggregateInput
    _max?: OrdemProducaoMaxOrderByAggregateInput
    _min?: OrdemProducaoMinOrderByAggregateInput
    _sum?: OrdemProducaoSumOrderByAggregateInput
  }

  export type OrdemProducaoScalarWhereWithAggregatesInput = {
    AND?: OrdemProducaoScalarWhereWithAggregatesInput | OrdemProducaoScalarWhereWithAggregatesInput[]
    OR?: OrdemProducaoScalarWhereWithAggregatesInput[]
    NOT?: OrdemProducaoScalarWhereWithAggregatesInput | OrdemProducaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrdemProducao"> | number
    pedidoId?: IntWithAggregatesFilter<"OrdemProducao"> | number
    setor?: StringWithAggregatesFilter<"OrdemProducao"> | string
    status?: StringWithAggregatesFilter<"OrdemProducao"> | string
    criadaEm?: DateTimeWithAggregatesFilter<"OrdemProducao"> | Date | string
    finalizadaEm?: DateTimeNullableWithAggregatesFilter<"OrdemProducao"> | Date | string | null
  }

  export type OrdemItemWhereInput = {
    AND?: OrdemItemWhereInput | OrdemItemWhereInput[]
    OR?: OrdemItemWhereInput[]
    NOT?: OrdemItemWhereInput | OrdemItemWhereInput[]
    id?: IntFilter<"OrdemItem"> | number
    ordemProducaoId?: IntFilter<"OrdemItem"> | number
    pedidoItemId?: IntFilter<"OrdemItem"> | number
    ordemProducao?: XOR<OrdemProducaoRelationFilter, OrdemProducaoWhereInput>
    pedidoItem?: XOR<PedidoItemRelationFilter, PedidoItemWhereInput>
  }

  export type OrdemItemOrderByWithRelationInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
    ordemProducao?: OrdemProducaoOrderByWithRelationInput
    pedidoItem?: PedidoItemOrderByWithRelationInput
  }

  export type OrdemItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrdemItemWhereInput | OrdemItemWhereInput[]
    OR?: OrdemItemWhereInput[]
    NOT?: OrdemItemWhereInput | OrdemItemWhereInput[]
    ordemProducaoId?: IntFilter<"OrdemItem"> | number
    pedidoItemId?: IntFilter<"OrdemItem"> | number
    ordemProducao?: XOR<OrdemProducaoRelationFilter, OrdemProducaoWhereInput>
    pedidoItem?: XOR<PedidoItemRelationFilter, PedidoItemWhereInput>
  }, "id">

  export type OrdemItemOrderByWithAggregationInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
    _count?: OrdemItemCountOrderByAggregateInput
    _avg?: OrdemItemAvgOrderByAggregateInput
    _max?: OrdemItemMaxOrderByAggregateInput
    _min?: OrdemItemMinOrderByAggregateInput
    _sum?: OrdemItemSumOrderByAggregateInput
  }

  export type OrdemItemScalarWhereWithAggregatesInput = {
    AND?: OrdemItemScalarWhereWithAggregatesInput | OrdemItemScalarWhereWithAggregatesInput[]
    OR?: OrdemItemScalarWhereWithAggregatesInput[]
    NOT?: OrdemItemScalarWhereWithAggregatesInput | OrdemItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrdemItem"> | number
    ordemProducaoId?: IntWithAggregatesFilter<"OrdemItem"> | number
    pedidoItemId?: IntWithAggregatesFilter<"OrdemItem"> | number
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    comandaId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    valor?: FloatFilter<"Pagamento"> | number
    status?: StringFilter<"Pagamento"> | string
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    comanda?: XOR<ComandaRelationFilter, ComandaWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    comandaId?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    comanda?: ComandaOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    comandaId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    valor?: FloatFilter<"Pagamento"> | number
    status?: StringFilter<"Pagamento"> | string
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    comanda?: XOR<ComandaRelationFilter, ComandaWhereInput>
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    comandaId?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pagamento"> | number
    comandaId?: IntWithAggregatesFilter<"Pagamento"> | number
    tipo?: StringWithAggregatesFilter<"Pagamento"> | string
    valor?: FloatWithAggregatesFilter<"Pagamento"> | number
    status?: StringWithAggregatesFilter<"Pagamento"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
  }

  export type LogStatusWhereInput = {
    AND?: LogStatusWhereInput | LogStatusWhereInput[]
    OR?: LogStatusWhereInput[]
    NOT?: LogStatusWhereInput | LogStatusWhereInput[]
    id?: IntFilter<"LogStatus"> | number
    entidade?: StringFilter<"LogStatus"> | string
    entidadeId?: IntFilter<"LogStatus"> | number
    status?: StringFilter<"LogStatus"> | string
    usuarioId?: IntNullableFilter<"LogStatus"> | number | null
    criadoEm?: DateTimeFilter<"LogStatus"> | Date | string
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type LogStatusOrderByWithRelationInput = {
    id?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    status?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type LogStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogStatusWhereInput | LogStatusWhereInput[]
    OR?: LogStatusWhereInput[]
    NOT?: LogStatusWhereInput | LogStatusWhereInput[]
    entidade?: StringFilter<"LogStatus"> | string
    entidadeId?: IntFilter<"LogStatus"> | number
    status?: StringFilter<"LogStatus"> | string
    usuarioId?: IntNullableFilter<"LogStatus"> | number | null
    criadoEm?: DateTimeFilter<"LogStatus"> | Date | string
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type LogStatusOrderByWithAggregationInput = {
    id?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    status?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    _count?: LogStatusCountOrderByAggregateInput
    _avg?: LogStatusAvgOrderByAggregateInput
    _max?: LogStatusMaxOrderByAggregateInput
    _min?: LogStatusMinOrderByAggregateInput
    _sum?: LogStatusSumOrderByAggregateInput
  }

  export type LogStatusScalarWhereWithAggregatesInput = {
    AND?: LogStatusScalarWhereWithAggregatesInput | LogStatusScalarWhereWithAggregatesInput[]
    OR?: LogStatusScalarWhereWithAggregatesInput[]
    NOT?: LogStatusScalarWhereWithAggregatesInput | LogStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogStatus"> | number
    entidade?: StringWithAggregatesFilter<"LogStatus"> | string
    entidadeId?: IntWithAggregatesFilter<"LogStatus"> | number
    status?: StringWithAggregatesFilter<"LogStatus"> | string
    usuarioId?: IntNullableWithAggregatesFilter<"LogStatus"> | number | null
    criadoEm?: DateTimeWithAggregatesFilter<"LogStatus"> | Date | string
  }

  export type PrinterConfigWhereInput = {
    AND?: PrinterConfigWhereInput | PrinterConfigWhereInput[]
    OR?: PrinterConfigWhereInput[]
    NOT?: PrinterConfigWhereInput | PrinterConfigWhereInput[]
    id?: IntFilter<"PrinterConfig"> | number
    setor?: StringFilter<"PrinterConfig"> | string
    name?: StringFilter<"PrinterConfig"> | string
    ip?: StringFilter<"PrinterConfig"> | string
    port?: IntFilter<"PrinterConfig"> | number
    enabled?: BoolFilter<"PrinterConfig"> | boolean
  }

  export type PrinterConfigOrderByWithRelationInput = {
    id?: SortOrder
    setor?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    port?: SortOrder
    enabled?: SortOrder
  }

  export type PrinterConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    setor?: string
    AND?: PrinterConfigWhereInput | PrinterConfigWhereInput[]
    OR?: PrinterConfigWhereInput[]
    NOT?: PrinterConfigWhereInput | PrinterConfigWhereInput[]
    name?: StringFilter<"PrinterConfig"> | string
    ip?: StringFilter<"PrinterConfig"> | string
    port?: IntFilter<"PrinterConfig"> | number
    enabled?: BoolFilter<"PrinterConfig"> | boolean
  }, "id" | "setor">

  export type PrinterConfigOrderByWithAggregationInput = {
    id?: SortOrder
    setor?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    port?: SortOrder
    enabled?: SortOrder
    _count?: PrinterConfigCountOrderByAggregateInput
    _avg?: PrinterConfigAvgOrderByAggregateInput
    _max?: PrinterConfigMaxOrderByAggregateInput
    _min?: PrinterConfigMinOrderByAggregateInput
    _sum?: PrinterConfigSumOrderByAggregateInput
  }

  export type PrinterConfigScalarWhereWithAggregatesInput = {
    AND?: PrinterConfigScalarWhereWithAggregatesInput | PrinterConfigScalarWhereWithAggregatesInput[]
    OR?: PrinterConfigScalarWhereWithAggregatesInput[]
    NOT?: PrinterConfigScalarWhereWithAggregatesInput | PrinterConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrinterConfig"> | number
    setor?: StringWithAggregatesFilter<"PrinterConfig"> | string
    name?: StringWithAggregatesFilter<"PrinterConfig"> | string
    ip?: StringWithAggregatesFilter<"PrinterConfig"> | string
    port?: IntWithAggregatesFilter<"PrinterConfig"> | number
    enabled?: BoolWithAggregatesFilter<"PrinterConfig"> | boolean
  }

  export type MesaCreateInput = {
    numero: number
    status?: string
    comandas?: ComandaCreateNestedManyWithoutMesaInput
  }

  export type MesaUncheckedCreateInput = {
    id?: number
    numero: number
    status?: string
    comandas?: ComandaUncheckedCreateNestedManyWithoutMesaInput
  }

  export type MesaUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    comandas?: ComandaUpdateManyWithoutMesaNestedInput
  }

  export type MesaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    comandas?: ComandaUncheckedUpdateManyWithoutMesaNestedInput
  }

  export type MesaCreateManyInput = {
    id?: number
    numero: number
    status?: string
  }

  export type MesaUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MesaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoCreateNestedManyWithoutGarcomInput
    comandas?: ComandaCreateNestedManyWithoutUsuarioInput
    logs?: LogStatusCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutGarcomInput
    comandas?: ComandaUncheckedCreateNestedManyWithoutUsuarioInput
    logs?: LogStatusUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutGarcomNestedInput
    comandas?: ComandaUpdateManyWithoutUsuarioNestedInput
    logs?: LogStatusUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutGarcomNestedInput
    comandas?: ComandaUncheckedUpdateManyWithoutUsuarioNestedInput
    logs?: LogStatusUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nome: string
    login: string
    role: string
    senha: string
  }

  export type UsuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type ComandaCreateInput = {
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    mesa: MesaCreateNestedOneWithoutComandasInput
    usuario?: UsuarioCreateNestedOneWithoutComandasInput
    pedidos?: PedidoCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoCreateNestedManyWithoutComandaInput
  }

  export type ComandaUncheckedCreateInput = {
    id?: number
    mesaId: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutComandaInput
  }

  export type ComandaUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mesa?: MesaUpdateOneRequiredWithoutComandasNestedInput
    usuario?: UsuarioUpdateOneWithoutComandasNestedInput
    pedidos?: PedidoUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUncheckedUpdateManyWithoutComandaNestedInput
  }

  export type ComandaCreateManyInput = {
    id?: number
    mesaId: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
  }

  export type ComandaUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComandaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PedidoCreateInput = {
    status?: string
    criadoEm?: Date | string
    comanda: ComandaCreateNestedOneWithoutPedidosInput
    garcom?: UsuarioCreateNestedOneWithoutPedidosInput
    itens?: PedidoItemCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    comandaId: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
    itens?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comanda?: ComandaUpdateOneRequiredWithoutPedidosNestedInput
    garcom?: UsuarioUpdateOneWithoutPedidosNestedInput
    itens?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    comandaId: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
  }

  export type PedidoUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaCreateInput = {
    nome: string
    setor: string
    produtos?: ProdutoCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nome: string
    setor: string
    produtos?: ProdutoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
    produtos?: ProdutoUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
    produtos?: ProdutoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nome: string
    setor: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
  }

  export type ProdutoCreateInput = {
    nome: string
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
    categoria?: CategoriaCreateNestedOneWithoutProdutosInput
    itens?: PedidoItemCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateInput = {
    id?: number
    nome: string
    categoriaId?: number | null
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
    itens?: PedidoItemUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneWithoutProdutosNestedInput
    itens?: PedidoItemUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
    itens?: PedidoItemUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoCreateManyInput = {
    id?: number
    nome: string
    categoriaId?: number | null
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
  }

  export type ProdutoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProdutoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoItemCreateInput = {
    quantidade: number
    observacao?: string | null
    status?: string
    pedido: PedidoCreateNestedOneWithoutItensInput
    produto: ProdutoCreateNestedOneWithoutItensInput
    ordemItens?: OrdemItemCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemUncheckedCreateInput = {
    id?: number
    pedidoId: number
    produtoId: number
    quantidade: number
    observacao?: string | null
    status?: string
    ordemItens?: OrdemItemUncheckedCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemUpdateInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    pedido?: PedidoUpdateOneRequiredWithoutItensNestedInput
    produto?: ProdutoUpdateOneRequiredWithoutItensNestedInput
    ordemItens?: OrdemItemUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordemItens?: OrdemItemUncheckedUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemCreateManyInput = {
    id?: number
    pedidoId: number
    produtoId: number
    quantidade: number
    observacao?: string | null
    status?: string
  }

  export type PedidoItemUpdateManyMutationInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OrdemProducaoCreateInput = {
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
    pedido: PedidoCreateNestedOneWithoutOrdensProducaoInput
    itens?: OrdemItemCreateNestedManyWithoutOrdemProducaoInput
  }

  export type OrdemProducaoUncheckedCreateInput = {
    id?: number
    pedidoId: number
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
    itens?: OrdemItemUncheckedCreateNestedManyWithoutOrdemProducaoInput
  }

  export type OrdemProducaoUpdateInput = {
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedido?: PedidoUpdateOneRequiredWithoutOrdensProducaoNestedInput
    itens?: OrdemItemUpdateManyWithoutOrdemProducaoNestedInput
  }

  export type OrdemProducaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itens?: OrdemItemUncheckedUpdateManyWithoutOrdemProducaoNestedInput
  }

  export type OrdemProducaoCreateManyInput = {
    id?: number
    pedidoId: number
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
  }

  export type OrdemProducaoUpdateManyMutationInput = {
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrdemProducaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrdemItemCreateInput = {
    ordemProducao: OrdemProducaoCreateNestedOneWithoutItensInput
    pedidoItem: PedidoItemCreateNestedOneWithoutOrdemItensInput
  }

  export type OrdemItemUncheckedCreateInput = {
    id?: number
    ordemProducaoId: number
    pedidoItemId: number
  }

  export type OrdemItemUpdateInput = {
    ordemProducao?: OrdemProducaoUpdateOneRequiredWithoutItensNestedInput
    pedidoItem?: PedidoItemUpdateOneRequiredWithoutOrdemItensNestedInput
  }

  export type OrdemItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordemProducaoId?: IntFieldUpdateOperationsInput | number
    pedidoItemId?: IntFieldUpdateOperationsInput | number
  }

  export type OrdemItemCreateManyInput = {
    id?: number
    ordemProducaoId: number
    pedidoItemId: number
  }

  export type OrdemItemUpdateManyMutationInput = {

  }

  export type OrdemItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordemProducaoId?: IntFieldUpdateOperationsInput | number
    pedidoItemId?: IntFieldUpdateOperationsInput | number
  }

  export type PagamentoCreateInput = {
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
    comanda: ComandaCreateNestedOneWithoutPagamentosInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: number
    comandaId: number
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
  }

  export type PagamentoUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comanda?: ComandaUpdateOneRequiredWithoutPagamentosNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyInput = {
    id?: number
    comandaId: number
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
  }

  export type PagamentoUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogStatusCreateInput = {
    entidade: string
    entidadeId: number
    status: string
    criadoEm?: Date | string
    usuario?: UsuarioCreateNestedOneWithoutLogsInput
  }

  export type LogStatusUncheckedCreateInput = {
    id?: number
    entidade: string
    entidadeId: number
    status: string
    usuarioId?: number | null
    criadoEm?: Date | string
  }

  export type LogStatusUpdateInput = {
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneWithoutLogsNestedInput
  }

  export type LogStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogStatusCreateManyInput = {
    id?: number
    entidade: string
    entidadeId: number
    status: string
    usuarioId?: number | null
    criadoEm?: Date | string
  }

  export type LogStatusUpdateManyMutationInput = {
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrinterConfigCreateInput = {
    setor: string
    name: string
    ip: string
    port?: number
    enabled?: boolean
  }

  export type PrinterConfigUncheckedCreateInput = {
    id?: number
    setor: string
    name: string
    ip: string
    port?: number
    enabled?: boolean
  }

  export type PrinterConfigUpdateInput = {
    setor?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrinterConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrinterConfigCreateManyInput = {
    id?: number
    setor: string
    name: string
    ip: string
    port?: number
    enabled?: boolean
  }

  export type PrinterConfigUpdateManyMutationInput = {
    setor?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrinterConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ComandaListRelationFilter = {
    every?: ComandaWhereInput
    some?: ComandaWhereInput
    none?: ComandaWhereInput
  }

  export type ComandaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MesaCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    status?: SortOrder
  }

  export type MesaAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type MesaMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    status?: SortOrder
  }

  export type MesaMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    status?: SortOrder
  }

  export type MesaSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type LogStatusListRelationFilter = {
    every?: LogStatusWhereInput
    some?: LogStatusWhereInput
    none?: LogStatusWhereInput
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    login?: SortOrder
    role?: SortOrder
    senha?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    login?: SortOrder
    role?: SortOrder
    senha?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    login?: SortOrder
    role?: SortOrder
    senha?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MesaRelationFilter = {
    is?: MesaWhereInput
    isNot?: MesaWhereInput
  }

  export type UsuarioNullableRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComandaCountOrderByAggregateInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    abertaEm?: SortOrder
    fechadaEm?: SortOrder
  }

  export type ComandaAvgOrderByAggregateInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrder
    total?: SortOrder
  }

  export type ComandaMaxOrderByAggregateInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    abertaEm?: SortOrder
    fechadaEm?: SortOrder
  }

  export type ComandaMinOrderByAggregateInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    abertaEm?: SortOrder
    fechadaEm?: SortOrder
  }

  export type ComandaSumOrderByAggregateInput = {
    id?: SortOrder
    mesaId?: SortOrder
    usuarioId?: SortOrder
    total?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ComandaRelationFilter = {
    is?: ComandaWhereInput
    isNot?: ComandaWhereInput
  }

  export type PedidoItemListRelationFilter = {
    every?: PedidoItemWhereInput
    some?: PedidoItemWhereInput
    none?: PedidoItemWhereInput
  }

  export type OrdemProducaoListRelationFilter = {
    every?: OrdemProducaoWhereInput
    some?: OrdemProducaoWhereInput
    none?: OrdemProducaoWhereInput
  }

  export type PedidoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdemProducaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    garcomId?: SortOrder
  }

  export type ProdutoListRelationFilter = {
    every?: ProdutoWhereInput
    some?: ProdutoWhereInput
    none?: ProdutoWhereInput
  }

  export type ProdutoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    setor?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    setor?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    setor?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CategoriaNullableRelationFilter = {
    is?: CategoriaWhereInput | null
    isNot?: CategoriaWhereInput | null
  }

  export type ProdutoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoriaId?: SortOrder
    preco?: SortOrder
    ativo?: SortOrder
    foto?: SortOrder
    tipoOpcao?: SortOrder
    sabores?: SortOrder
    isDrink?: SortOrder
    isFood?: SortOrder
    permitirObservacao?: SortOrder
    permiteGeloLimao?: SortOrder
    favorito?: SortOrder
    ultimoUso?: SortOrder
    estoque?: SortOrder
    esgotado?: SortOrder
  }

  export type ProdutoAvgOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    preco?: SortOrder
    estoque?: SortOrder
  }

  export type ProdutoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoriaId?: SortOrder
    preco?: SortOrder
    ativo?: SortOrder
    foto?: SortOrder
    tipoOpcao?: SortOrder
    sabores?: SortOrder
    isDrink?: SortOrder
    isFood?: SortOrder
    permitirObservacao?: SortOrder
    permiteGeloLimao?: SortOrder
    favorito?: SortOrder
    ultimoUso?: SortOrder
    estoque?: SortOrder
    esgotado?: SortOrder
  }

  export type ProdutoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoriaId?: SortOrder
    preco?: SortOrder
    ativo?: SortOrder
    foto?: SortOrder
    tipoOpcao?: SortOrder
    sabores?: SortOrder
    isDrink?: SortOrder
    isFood?: SortOrder
    permitirObservacao?: SortOrder
    permiteGeloLimao?: SortOrder
    favorito?: SortOrder
    ultimoUso?: SortOrder
    estoque?: SortOrder
    esgotado?: SortOrder
  }

  export type ProdutoSumOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    preco?: SortOrder
    estoque?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type ProdutoRelationFilter = {
    is?: ProdutoWhereInput
    isNot?: ProdutoWhereInput
  }

  export type OrdemItemListRelationFilter = {
    every?: OrdemItemWhereInput
    some?: OrdemItemWhereInput
    none?: OrdemItemWhereInput
  }

  export type OrdemItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoItemCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
    observacao?: SortOrder
    status?: SortOrder
  }

  export type PedidoItemAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
  }

  export type PedidoItemMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
    observacao?: SortOrder
    status?: SortOrder
  }

  export type PedidoItemMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
    observacao?: SortOrder
    status?: SortOrder
  }

  export type PedidoItemSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    produtoId?: SortOrder
    quantidade?: SortOrder
  }

  export type OrdemProducaoCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    setor?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
    finalizadaEm?: SortOrder
  }

  export type OrdemProducaoAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
  }

  export type OrdemProducaoMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    setor?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
    finalizadaEm?: SortOrder
  }

  export type OrdemProducaoMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    setor?: SortOrder
    status?: SortOrder
    criadaEm?: SortOrder
    finalizadaEm?: SortOrder
  }

  export type OrdemProducaoSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
  }

  export type OrdemProducaoRelationFilter = {
    is?: OrdemProducaoWhereInput
    isNot?: OrdemProducaoWhereInput
  }

  export type PedidoItemRelationFilter = {
    is?: PedidoItemWhereInput
    isNot?: PedidoItemWhereInput
  }

  export type OrdemItemCountOrderByAggregateInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
  }

  export type OrdemItemAvgOrderByAggregateInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
  }

  export type OrdemItemMaxOrderByAggregateInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
  }

  export type OrdemItemMinOrderByAggregateInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
  }

  export type OrdemItemSumOrderByAggregateInput = {
    id?: SortOrder
    ordemProducaoId?: SortOrder
    pedidoItemId?: SortOrder
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    valor?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    tipo?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    criadoEm?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    comandaId?: SortOrder
    valor?: SortOrder
  }

  export type LogStatusCountOrderByAggregateInput = {
    id?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    status?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type LogStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    entidadeId?: SortOrder
    usuarioId?: SortOrder
  }

  export type LogStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    status?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type LogStatusMinOrderByAggregateInput = {
    id?: SortOrder
    entidade?: SortOrder
    entidadeId?: SortOrder
    status?: SortOrder
    usuarioId?: SortOrder
    criadoEm?: SortOrder
  }

  export type LogStatusSumOrderByAggregateInput = {
    id?: SortOrder
    entidadeId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PrinterConfigCountOrderByAggregateInput = {
    id?: SortOrder
    setor?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    port?: SortOrder
    enabled?: SortOrder
  }

  export type PrinterConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type PrinterConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    setor?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    port?: SortOrder
    enabled?: SortOrder
  }

  export type PrinterConfigMinOrderByAggregateInput = {
    id?: SortOrder
    setor?: SortOrder
    name?: SortOrder
    ip?: SortOrder
    port?: SortOrder
    enabled?: SortOrder
  }

  export type PrinterConfigSumOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type ComandaCreateNestedManyWithoutMesaInput = {
    create?: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput> | ComandaCreateWithoutMesaInput[] | ComandaUncheckedCreateWithoutMesaInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutMesaInput | ComandaCreateOrConnectWithoutMesaInput[]
    createMany?: ComandaCreateManyMesaInputEnvelope
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
  }

  export type ComandaUncheckedCreateNestedManyWithoutMesaInput = {
    create?: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput> | ComandaCreateWithoutMesaInput[] | ComandaUncheckedCreateWithoutMesaInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutMesaInput | ComandaCreateOrConnectWithoutMesaInput[]
    createMany?: ComandaCreateManyMesaInputEnvelope
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ComandaUpdateManyWithoutMesaNestedInput = {
    create?: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput> | ComandaCreateWithoutMesaInput[] | ComandaUncheckedCreateWithoutMesaInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutMesaInput | ComandaCreateOrConnectWithoutMesaInput[]
    upsert?: ComandaUpsertWithWhereUniqueWithoutMesaInput | ComandaUpsertWithWhereUniqueWithoutMesaInput[]
    createMany?: ComandaCreateManyMesaInputEnvelope
    set?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    disconnect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    delete?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    update?: ComandaUpdateWithWhereUniqueWithoutMesaInput | ComandaUpdateWithWhereUniqueWithoutMesaInput[]
    updateMany?: ComandaUpdateManyWithWhereWithoutMesaInput | ComandaUpdateManyWithWhereWithoutMesaInput[]
    deleteMany?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
  }

  export type ComandaUncheckedUpdateManyWithoutMesaNestedInput = {
    create?: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput> | ComandaCreateWithoutMesaInput[] | ComandaUncheckedCreateWithoutMesaInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutMesaInput | ComandaCreateOrConnectWithoutMesaInput[]
    upsert?: ComandaUpsertWithWhereUniqueWithoutMesaInput | ComandaUpsertWithWhereUniqueWithoutMesaInput[]
    createMany?: ComandaCreateManyMesaInputEnvelope
    set?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    disconnect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    delete?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    update?: ComandaUpdateWithWhereUniqueWithoutMesaInput | ComandaUpdateWithWhereUniqueWithoutMesaInput[]
    updateMany?: ComandaUpdateManyWithWhereWithoutMesaInput | ComandaUpdateManyWithWhereWithoutMesaInput[]
    deleteMany?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
  }

  export type PedidoCreateNestedManyWithoutGarcomInput = {
    create?: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput> | PedidoCreateWithoutGarcomInput[] | PedidoUncheckedCreateWithoutGarcomInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutGarcomInput | PedidoCreateOrConnectWithoutGarcomInput[]
    createMany?: PedidoCreateManyGarcomInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type ComandaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput> | ComandaCreateWithoutUsuarioInput[] | ComandaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutUsuarioInput | ComandaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComandaCreateManyUsuarioInputEnvelope
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
  }

  export type LogStatusCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput> | LogStatusCreateWithoutUsuarioInput[] | LogStatusUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogStatusCreateOrConnectWithoutUsuarioInput | LogStatusCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogStatusCreateManyUsuarioInputEnvelope
    connect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutGarcomInput = {
    create?: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput> | PedidoCreateWithoutGarcomInput[] | PedidoUncheckedCreateWithoutGarcomInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutGarcomInput | PedidoCreateOrConnectWithoutGarcomInput[]
    createMany?: PedidoCreateManyGarcomInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type ComandaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput> | ComandaCreateWithoutUsuarioInput[] | ComandaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutUsuarioInput | ComandaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComandaCreateManyUsuarioInputEnvelope
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
  }

  export type LogStatusUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput> | LogStatusCreateWithoutUsuarioInput[] | LogStatusUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogStatusCreateOrConnectWithoutUsuarioInput | LogStatusCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogStatusCreateManyUsuarioInputEnvelope
    connect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
  }

  export type PedidoUpdateManyWithoutGarcomNestedInput = {
    create?: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput> | PedidoCreateWithoutGarcomInput[] | PedidoUncheckedCreateWithoutGarcomInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutGarcomInput | PedidoCreateOrConnectWithoutGarcomInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutGarcomInput | PedidoUpsertWithWhereUniqueWithoutGarcomInput[]
    createMany?: PedidoCreateManyGarcomInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutGarcomInput | PedidoUpdateWithWhereUniqueWithoutGarcomInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutGarcomInput | PedidoUpdateManyWithWhereWithoutGarcomInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ComandaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput> | ComandaCreateWithoutUsuarioInput[] | ComandaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutUsuarioInput | ComandaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComandaUpsertWithWhereUniqueWithoutUsuarioInput | ComandaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComandaCreateManyUsuarioInputEnvelope
    set?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    disconnect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    delete?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    update?: ComandaUpdateWithWhereUniqueWithoutUsuarioInput | ComandaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComandaUpdateManyWithWhereWithoutUsuarioInput | ComandaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
  }

  export type LogStatusUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput> | LogStatusCreateWithoutUsuarioInput[] | LogStatusUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogStatusCreateOrConnectWithoutUsuarioInput | LogStatusCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogStatusUpsertWithWhereUniqueWithoutUsuarioInput | LogStatusUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogStatusCreateManyUsuarioInputEnvelope
    set?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    disconnect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    delete?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    connect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    update?: LogStatusUpdateWithWhereUniqueWithoutUsuarioInput | LogStatusUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogStatusUpdateManyWithWhereWithoutUsuarioInput | LogStatusUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogStatusScalarWhereInput | LogStatusScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutGarcomNestedInput = {
    create?: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput> | PedidoCreateWithoutGarcomInput[] | PedidoUncheckedCreateWithoutGarcomInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutGarcomInput | PedidoCreateOrConnectWithoutGarcomInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutGarcomInput | PedidoUpsertWithWhereUniqueWithoutGarcomInput[]
    createMany?: PedidoCreateManyGarcomInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutGarcomInput | PedidoUpdateWithWhereUniqueWithoutGarcomInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutGarcomInput | PedidoUpdateManyWithWhereWithoutGarcomInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ComandaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput> | ComandaCreateWithoutUsuarioInput[] | ComandaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComandaCreateOrConnectWithoutUsuarioInput | ComandaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComandaUpsertWithWhereUniqueWithoutUsuarioInput | ComandaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComandaCreateManyUsuarioInputEnvelope
    set?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    disconnect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    delete?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    connect?: ComandaWhereUniqueInput | ComandaWhereUniqueInput[]
    update?: ComandaUpdateWithWhereUniqueWithoutUsuarioInput | ComandaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComandaUpdateManyWithWhereWithoutUsuarioInput | ComandaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
  }

  export type LogStatusUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput> | LogStatusCreateWithoutUsuarioInput[] | LogStatusUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogStatusCreateOrConnectWithoutUsuarioInput | LogStatusCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogStatusUpsertWithWhereUniqueWithoutUsuarioInput | LogStatusUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogStatusCreateManyUsuarioInputEnvelope
    set?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    disconnect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    delete?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    connect?: LogStatusWhereUniqueInput | LogStatusWhereUniqueInput[]
    update?: LogStatusUpdateWithWhereUniqueWithoutUsuarioInput | LogStatusUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogStatusUpdateManyWithWhereWithoutUsuarioInput | LogStatusUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogStatusScalarWhereInput | LogStatusScalarWhereInput[]
  }

  export type MesaCreateNestedOneWithoutComandasInput = {
    create?: XOR<MesaCreateWithoutComandasInput, MesaUncheckedCreateWithoutComandasInput>
    connectOrCreate?: MesaCreateOrConnectWithoutComandasInput
    connect?: MesaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComandasInput = {
    create?: XOR<UsuarioCreateWithoutComandasInput, UsuarioUncheckedCreateWithoutComandasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComandasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutComandaInput = {
    create?: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput> | PedidoCreateWithoutComandaInput[] | PedidoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutComandaInput | PedidoCreateOrConnectWithoutComandaInput[]
    createMany?: PedidoCreateManyComandaInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PagamentoCreateNestedManyWithoutComandaInput = {
    create?: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput> | PagamentoCreateWithoutComandaInput[] | PagamentoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutComandaInput | PagamentoCreateOrConnectWithoutComandaInput[]
    createMany?: PagamentoCreateManyComandaInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutComandaInput = {
    create?: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput> | PedidoCreateWithoutComandaInput[] | PedidoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutComandaInput | PedidoCreateOrConnectWithoutComandaInput[]
    createMany?: PedidoCreateManyComandaInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutComandaInput = {
    create?: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput> | PagamentoCreateWithoutComandaInput[] | PagamentoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutComandaInput | PagamentoCreateOrConnectWithoutComandaInput[]
    createMany?: PagamentoCreateManyComandaInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MesaUpdateOneRequiredWithoutComandasNestedInput = {
    create?: XOR<MesaCreateWithoutComandasInput, MesaUncheckedCreateWithoutComandasInput>
    connectOrCreate?: MesaCreateOrConnectWithoutComandasInput
    upsert?: MesaUpsertWithoutComandasInput
    connect?: MesaWhereUniqueInput
    update?: XOR<XOR<MesaUpdateToOneWithWhereWithoutComandasInput, MesaUpdateWithoutComandasInput>, MesaUncheckedUpdateWithoutComandasInput>
  }

  export type UsuarioUpdateOneWithoutComandasNestedInput = {
    create?: XOR<UsuarioCreateWithoutComandasInput, UsuarioUncheckedCreateWithoutComandasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComandasInput
    upsert?: UsuarioUpsertWithoutComandasInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComandasInput, UsuarioUpdateWithoutComandasInput>, UsuarioUncheckedUpdateWithoutComandasInput>
  }

  export type PedidoUpdateManyWithoutComandaNestedInput = {
    create?: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput> | PedidoCreateWithoutComandaInput[] | PedidoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutComandaInput | PedidoCreateOrConnectWithoutComandaInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutComandaInput | PedidoUpsertWithWhereUniqueWithoutComandaInput[]
    createMany?: PedidoCreateManyComandaInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutComandaInput | PedidoUpdateWithWhereUniqueWithoutComandaInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutComandaInput | PedidoUpdateManyWithWhereWithoutComandaInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type PagamentoUpdateManyWithoutComandaNestedInput = {
    create?: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput> | PagamentoCreateWithoutComandaInput[] | PagamentoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutComandaInput | PagamentoCreateOrConnectWithoutComandaInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutComandaInput | PagamentoUpsertWithWhereUniqueWithoutComandaInput[]
    createMany?: PagamentoCreateManyComandaInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutComandaInput | PagamentoUpdateWithWhereUniqueWithoutComandaInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutComandaInput | PagamentoUpdateManyWithWhereWithoutComandaInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PedidoUncheckedUpdateManyWithoutComandaNestedInput = {
    create?: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput> | PedidoCreateWithoutComandaInput[] | PedidoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutComandaInput | PedidoCreateOrConnectWithoutComandaInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutComandaInput | PedidoUpsertWithWhereUniqueWithoutComandaInput[]
    createMany?: PedidoCreateManyComandaInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutComandaInput | PedidoUpdateWithWhereUniqueWithoutComandaInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutComandaInput | PedidoUpdateManyWithWhereWithoutComandaInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutComandaNestedInput = {
    create?: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput> | PagamentoCreateWithoutComandaInput[] | PagamentoUncheckedCreateWithoutComandaInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutComandaInput | PagamentoCreateOrConnectWithoutComandaInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutComandaInput | PagamentoUpsertWithWhereUniqueWithoutComandaInput[]
    createMany?: PagamentoCreateManyComandaInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutComandaInput | PagamentoUpdateWithWhereUniqueWithoutComandaInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutComandaInput | PagamentoUpdateManyWithWhereWithoutComandaInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type ComandaCreateNestedOneWithoutPedidosInput = {
    create?: XOR<ComandaCreateWithoutPedidosInput, ComandaUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ComandaCreateOrConnectWithoutPedidosInput
    connect?: ComandaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type OrdemProducaoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput> | OrdemProducaoCreateWithoutPedidoInput[] | OrdemProducaoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutPedidoInput | OrdemProducaoCreateOrConnectWithoutPedidoInput[]
    createMany?: OrdemProducaoCreateManyPedidoInputEnvelope
    connect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type OrdemProducaoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput> | OrdemProducaoCreateWithoutPedidoInput[] | OrdemProducaoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutPedidoInput | OrdemProducaoCreateOrConnectWithoutPedidoInput[]
    createMany?: OrdemProducaoCreateManyPedidoInputEnvelope
    connect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
  }

  export type ComandaUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<ComandaCreateWithoutPedidosInput, ComandaUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ComandaCreateOrConnectWithoutPedidosInput
    upsert?: ComandaUpsertWithoutPedidosInput
    connect?: ComandaWhereUniqueInput
    update?: XOR<XOR<ComandaUpdateToOneWithWhereWithoutPedidosInput, ComandaUpdateWithoutPedidosInput>, ComandaUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateOneWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPedidosInput, UsuarioUpdateWithoutPedidosInput>, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type PedidoItemUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type OrdemProducaoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput> | OrdemProducaoCreateWithoutPedidoInput[] | OrdemProducaoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutPedidoInput | OrdemProducaoCreateOrConnectWithoutPedidoInput[]
    upsert?: OrdemProducaoUpsertWithWhereUniqueWithoutPedidoInput | OrdemProducaoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: OrdemProducaoCreateManyPedidoInputEnvelope
    set?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    disconnect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    delete?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    connect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    update?: OrdemProducaoUpdateWithWhereUniqueWithoutPedidoInput | OrdemProducaoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: OrdemProducaoUpdateManyWithWhereWithoutPedidoInput | OrdemProducaoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: OrdemProducaoScalarWhereInput | OrdemProducaoScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type OrdemProducaoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput> | OrdemProducaoCreateWithoutPedidoInput[] | OrdemProducaoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutPedidoInput | OrdemProducaoCreateOrConnectWithoutPedidoInput[]
    upsert?: OrdemProducaoUpsertWithWhereUniqueWithoutPedidoInput | OrdemProducaoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: OrdemProducaoCreateManyPedidoInputEnvelope
    set?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    disconnect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    delete?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    connect?: OrdemProducaoWhereUniqueInput | OrdemProducaoWhereUniqueInput[]
    update?: OrdemProducaoUpdateWithWhereUniqueWithoutPedidoInput | OrdemProducaoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: OrdemProducaoUpdateManyWithWhereWithoutPedidoInput | OrdemProducaoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: OrdemProducaoScalarWhereInput | OrdemProducaoScalarWhereInput[]
  }

  export type ProdutoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput> | ProdutoCreateWithoutCategoriaInput[] | ProdutoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaInput | ProdutoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProdutoCreateManyCategoriaInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ProdutoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput> | ProdutoCreateWithoutCategoriaInput[] | ProdutoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaInput | ProdutoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProdutoCreateManyCategoriaInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ProdutoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput> | ProdutoCreateWithoutCategoriaInput[] | ProdutoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaInput | ProdutoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutCategoriaInput | ProdutoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProdutoCreateManyCategoriaInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutCategoriaInput | ProdutoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutCategoriaInput | ProdutoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type ProdutoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput> | ProdutoCreateWithoutCategoriaInput[] | ProdutoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutCategoriaInput | ProdutoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutCategoriaInput | ProdutoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProdutoCreateManyCategoriaInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutCategoriaInput | ProdutoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutCategoriaInput | ProdutoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type CategoriaCreateNestedOneWithoutProdutosInput = {
    create?: XOR<CategoriaCreateWithoutProdutosInput, CategoriaUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProdutosInput
    connect?: CategoriaWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutProdutoInput = {
    create?: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput> | PedidoItemCreateWithoutProdutoInput[] | PedidoItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProdutoInput | PedidoItemCreateOrConnectWithoutProdutoInput[]
    createMany?: PedidoItemCreateManyProdutoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutProdutoInput = {
    create?: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput> | PedidoItemCreateWithoutProdutoInput[] | PedidoItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProdutoInput | PedidoItemCreateOrConnectWithoutProdutoInput[]
    createMany?: PedidoItemCreateManyProdutoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CategoriaUpdateOneWithoutProdutosNestedInput = {
    create?: XOR<CategoriaCreateWithoutProdutosInput, CategoriaUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProdutosInput
    upsert?: CategoriaUpsertWithoutProdutosInput
    disconnect?: CategoriaWhereInput | boolean
    delete?: CategoriaWhereInput | boolean
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutProdutosInput, CategoriaUpdateWithoutProdutosInput>, CategoriaUncheckedUpdateWithoutProdutosInput>
  }

  export type PedidoItemUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput> | PedidoItemCreateWithoutProdutoInput[] | PedidoItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProdutoInput | PedidoItemCreateOrConnectWithoutProdutoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProdutoInput | PedidoItemUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: PedidoItemCreateManyProdutoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProdutoInput | PedidoItemUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProdutoInput | PedidoItemUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutProdutoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput> | PedidoItemCreateWithoutProdutoInput[] | PedidoItemUncheckedCreateWithoutProdutoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProdutoInput | PedidoItemCreateOrConnectWithoutProdutoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProdutoInput | PedidoItemUpsertWithWhereUniqueWithoutProdutoInput[]
    createMany?: PedidoItemCreateManyProdutoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProdutoInput | PedidoItemUpdateWithWhereUniqueWithoutProdutoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProdutoInput | PedidoItemUpdateManyWithWhereWithoutProdutoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutItensInput = {
    create?: XOR<PedidoCreateWithoutItensInput, PedidoUncheckedCreateWithoutItensInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItensInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProdutoCreateNestedOneWithoutItensInput = {
    create?: XOR<ProdutoCreateWithoutItensInput, ProdutoUncheckedCreateWithoutItensInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutItensInput
    connect?: ProdutoWhereUniqueInput
  }

  export type OrdemItemCreateNestedManyWithoutPedidoItemInput = {
    create?: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput> | OrdemItemCreateWithoutPedidoItemInput[] | OrdemItemUncheckedCreateWithoutPedidoItemInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutPedidoItemInput | OrdemItemCreateOrConnectWithoutPedidoItemInput[]
    createMany?: OrdemItemCreateManyPedidoItemInputEnvelope
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
  }

  export type OrdemItemUncheckedCreateNestedManyWithoutPedidoItemInput = {
    create?: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput> | OrdemItemCreateWithoutPedidoItemInput[] | OrdemItemUncheckedCreateWithoutPedidoItemInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutPedidoItemInput | OrdemItemCreateOrConnectWithoutPedidoItemInput[]
    createMany?: OrdemItemCreateManyPedidoItemInputEnvelope
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
  }

  export type PedidoUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<PedidoCreateWithoutItensInput, PedidoUncheckedCreateWithoutItensInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItensInput
    upsert?: PedidoUpsertWithoutItensInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutItensInput, PedidoUpdateWithoutItensInput>, PedidoUncheckedUpdateWithoutItensInput>
  }

  export type ProdutoUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<ProdutoCreateWithoutItensInput, ProdutoUncheckedCreateWithoutItensInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutItensInput
    upsert?: ProdutoUpsertWithoutItensInput
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutItensInput, ProdutoUpdateWithoutItensInput>, ProdutoUncheckedUpdateWithoutItensInput>
  }

  export type OrdemItemUpdateManyWithoutPedidoItemNestedInput = {
    create?: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput> | OrdemItemCreateWithoutPedidoItemInput[] | OrdemItemUncheckedCreateWithoutPedidoItemInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutPedidoItemInput | OrdemItemCreateOrConnectWithoutPedidoItemInput[]
    upsert?: OrdemItemUpsertWithWhereUniqueWithoutPedidoItemInput | OrdemItemUpsertWithWhereUniqueWithoutPedidoItemInput[]
    createMany?: OrdemItemCreateManyPedidoItemInputEnvelope
    set?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    disconnect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    delete?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    update?: OrdemItemUpdateWithWhereUniqueWithoutPedidoItemInput | OrdemItemUpdateWithWhereUniqueWithoutPedidoItemInput[]
    updateMany?: OrdemItemUpdateManyWithWhereWithoutPedidoItemInput | OrdemItemUpdateManyWithWhereWithoutPedidoItemInput[]
    deleteMany?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
  }

  export type OrdemItemUncheckedUpdateManyWithoutPedidoItemNestedInput = {
    create?: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput> | OrdemItemCreateWithoutPedidoItemInput[] | OrdemItemUncheckedCreateWithoutPedidoItemInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutPedidoItemInput | OrdemItemCreateOrConnectWithoutPedidoItemInput[]
    upsert?: OrdemItemUpsertWithWhereUniqueWithoutPedidoItemInput | OrdemItemUpsertWithWhereUniqueWithoutPedidoItemInput[]
    createMany?: OrdemItemCreateManyPedidoItemInputEnvelope
    set?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    disconnect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    delete?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    update?: OrdemItemUpdateWithWhereUniqueWithoutPedidoItemInput | OrdemItemUpdateWithWhereUniqueWithoutPedidoItemInput[]
    updateMany?: OrdemItemUpdateManyWithWhereWithoutPedidoItemInput | OrdemItemUpdateManyWithWhereWithoutPedidoItemInput[]
    deleteMany?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutOrdensProducaoInput = {
    create?: XOR<PedidoCreateWithoutOrdensProducaoInput, PedidoUncheckedCreateWithoutOrdensProducaoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutOrdensProducaoInput
    connect?: PedidoWhereUniqueInput
  }

  export type OrdemItemCreateNestedManyWithoutOrdemProducaoInput = {
    create?: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput> | OrdemItemCreateWithoutOrdemProducaoInput[] | OrdemItemUncheckedCreateWithoutOrdemProducaoInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutOrdemProducaoInput | OrdemItemCreateOrConnectWithoutOrdemProducaoInput[]
    createMany?: OrdemItemCreateManyOrdemProducaoInputEnvelope
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
  }

  export type OrdemItemUncheckedCreateNestedManyWithoutOrdemProducaoInput = {
    create?: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput> | OrdemItemCreateWithoutOrdemProducaoInput[] | OrdemItemUncheckedCreateWithoutOrdemProducaoInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutOrdemProducaoInput | OrdemItemCreateOrConnectWithoutOrdemProducaoInput[]
    createMany?: OrdemItemCreateManyOrdemProducaoInputEnvelope
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
  }

  export type PedidoUpdateOneRequiredWithoutOrdensProducaoNestedInput = {
    create?: XOR<PedidoCreateWithoutOrdensProducaoInput, PedidoUncheckedCreateWithoutOrdensProducaoInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutOrdensProducaoInput
    upsert?: PedidoUpsertWithoutOrdensProducaoInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutOrdensProducaoInput, PedidoUpdateWithoutOrdensProducaoInput>, PedidoUncheckedUpdateWithoutOrdensProducaoInput>
  }

  export type OrdemItemUpdateManyWithoutOrdemProducaoNestedInput = {
    create?: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput> | OrdemItemCreateWithoutOrdemProducaoInput[] | OrdemItemUncheckedCreateWithoutOrdemProducaoInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutOrdemProducaoInput | OrdemItemCreateOrConnectWithoutOrdemProducaoInput[]
    upsert?: OrdemItemUpsertWithWhereUniqueWithoutOrdemProducaoInput | OrdemItemUpsertWithWhereUniqueWithoutOrdemProducaoInput[]
    createMany?: OrdemItemCreateManyOrdemProducaoInputEnvelope
    set?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    disconnect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    delete?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    update?: OrdemItemUpdateWithWhereUniqueWithoutOrdemProducaoInput | OrdemItemUpdateWithWhereUniqueWithoutOrdemProducaoInput[]
    updateMany?: OrdemItemUpdateManyWithWhereWithoutOrdemProducaoInput | OrdemItemUpdateManyWithWhereWithoutOrdemProducaoInput[]
    deleteMany?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
  }

  export type OrdemItemUncheckedUpdateManyWithoutOrdemProducaoNestedInput = {
    create?: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput> | OrdemItemCreateWithoutOrdemProducaoInput[] | OrdemItemUncheckedCreateWithoutOrdemProducaoInput[]
    connectOrCreate?: OrdemItemCreateOrConnectWithoutOrdemProducaoInput | OrdemItemCreateOrConnectWithoutOrdemProducaoInput[]
    upsert?: OrdemItemUpsertWithWhereUniqueWithoutOrdemProducaoInput | OrdemItemUpsertWithWhereUniqueWithoutOrdemProducaoInput[]
    createMany?: OrdemItemCreateManyOrdemProducaoInputEnvelope
    set?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    disconnect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    delete?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    connect?: OrdemItemWhereUniqueInput | OrdemItemWhereUniqueInput[]
    update?: OrdemItemUpdateWithWhereUniqueWithoutOrdemProducaoInput | OrdemItemUpdateWithWhereUniqueWithoutOrdemProducaoInput[]
    updateMany?: OrdemItemUpdateManyWithWhereWithoutOrdemProducaoInput | OrdemItemUpdateManyWithWhereWithoutOrdemProducaoInput[]
    deleteMany?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
  }

  export type OrdemProducaoCreateNestedOneWithoutItensInput = {
    create?: XOR<OrdemProducaoCreateWithoutItensInput, OrdemProducaoUncheckedCreateWithoutItensInput>
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutItensInput
    connect?: OrdemProducaoWhereUniqueInput
  }

  export type PedidoItemCreateNestedOneWithoutOrdemItensInput = {
    create?: XOR<PedidoItemCreateWithoutOrdemItensInput, PedidoItemUncheckedCreateWithoutOrdemItensInput>
    connectOrCreate?: PedidoItemCreateOrConnectWithoutOrdemItensInput
    connect?: PedidoItemWhereUniqueInput
  }

  export type OrdemProducaoUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<OrdemProducaoCreateWithoutItensInput, OrdemProducaoUncheckedCreateWithoutItensInput>
    connectOrCreate?: OrdemProducaoCreateOrConnectWithoutItensInput
    upsert?: OrdemProducaoUpsertWithoutItensInput
    connect?: OrdemProducaoWhereUniqueInput
    update?: XOR<XOR<OrdemProducaoUpdateToOneWithWhereWithoutItensInput, OrdemProducaoUpdateWithoutItensInput>, OrdemProducaoUncheckedUpdateWithoutItensInput>
  }

  export type PedidoItemUpdateOneRequiredWithoutOrdemItensNestedInput = {
    create?: XOR<PedidoItemCreateWithoutOrdemItensInput, PedidoItemUncheckedCreateWithoutOrdemItensInput>
    connectOrCreate?: PedidoItemCreateOrConnectWithoutOrdemItensInput
    upsert?: PedidoItemUpsertWithoutOrdemItensInput
    connect?: PedidoItemWhereUniqueInput
    update?: XOR<XOR<PedidoItemUpdateToOneWithWhereWithoutOrdemItensInput, PedidoItemUpdateWithoutOrdemItensInput>, PedidoItemUncheckedUpdateWithoutOrdemItensInput>
  }

  export type ComandaCreateNestedOneWithoutPagamentosInput = {
    create?: XOR<ComandaCreateWithoutPagamentosInput, ComandaUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: ComandaCreateOrConnectWithoutPagamentosInput
    connect?: ComandaWhereUniqueInput
  }

  export type ComandaUpdateOneRequiredWithoutPagamentosNestedInput = {
    create?: XOR<ComandaCreateWithoutPagamentosInput, ComandaUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: ComandaCreateOrConnectWithoutPagamentosInput
    upsert?: ComandaUpsertWithoutPagamentosInput
    connect?: ComandaWhereUniqueInput
    update?: XOR<XOR<ComandaUpdateToOneWithWhereWithoutPagamentosInput, ComandaUpdateWithoutPagamentosInput>, ComandaUncheckedUpdateWithoutPagamentosInput>
  }

  export type UsuarioCreateNestedOneWithoutLogsInput = {
    create?: XOR<UsuarioCreateWithoutLogsInput, UsuarioUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLogsInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UsuarioCreateWithoutLogsInput, UsuarioUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLogsInput
    upsert?: UsuarioUpsertWithoutLogsInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutLogsInput, UsuarioUpdateWithoutLogsInput>, UsuarioUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ComandaCreateWithoutMesaInput = {
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    usuario?: UsuarioCreateNestedOneWithoutComandasInput
    pedidos?: PedidoCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoCreateNestedManyWithoutComandaInput
  }

  export type ComandaUncheckedCreateWithoutMesaInput = {
    id?: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutComandaInput
  }

  export type ComandaCreateOrConnectWithoutMesaInput = {
    where: ComandaWhereUniqueInput
    create: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput>
  }

  export type ComandaCreateManyMesaInputEnvelope = {
    data: ComandaCreateManyMesaInput | ComandaCreateManyMesaInput[]
    skipDuplicates?: boolean
  }

  export type ComandaUpsertWithWhereUniqueWithoutMesaInput = {
    where: ComandaWhereUniqueInput
    update: XOR<ComandaUpdateWithoutMesaInput, ComandaUncheckedUpdateWithoutMesaInput>
    create: XOR<ComandaCreateWithoutMesaInput, ComandaUncheckedCreateWithoutMesaInput>
  }

  export type ComandaUpdateWithWhereUniqueWithoutMesaInput = {
    where: ComandaWhereUniqueInput
    data: XOR<ComandaUpdateWithoutMesaInput, ComandaUncheckedUpdateWithoutMesaInput>
  }

  export type ComandaUpdateManyWithWhereWithoutMesaInput = {
    where: ComandaScalarWhereInput
    data: XOR<ComandaUpdateManyMutationInput, ComandaUncheckedUpdateManyWithoutMesaInput>
  }

  export type ComandaScalarWhereInput = {
    AND?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
    OR?: ComandaScalarWhereInput[]
    NOT?: ComandaScalarWhereInput | ComandaScalarWhereInput[]
    id?: IntFilter<"Comanda"> | number
    mesaId?: IntFilter<"Comanda"> | number
    usuarioId?: IntNullableFilter<"Comanda"> | number | null
    status?: StringFilter<"Comanda"> | string
    total?: FloatFilter<"Comanda"> | number
    abertaEm?: DateTimeFilter<"Comanda"> | Date | string
    fechadaEm?: DateTimeNullableFilter<"Comanda"> | Date | string | null
  }

  export type PedidoCreateWithoutGarcomInput = {
    status?: string
    criadoEm?: Date | string
    comanda: ComandaCreateNestedOneWithoutPedidosInput
    itens?: PedidoItemCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutGarcomInput = {
    id?: number
    comandaId: number
    status?: string
    criadoEm?: Date | string
    itens?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutGarcomInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput>
  }

  export type PedidoCreateManyGarcomInputEnvelope = {
    data: PedidoCreateManyGarcomInput | PedidoCreateManyGarcomInput[]
    skipDuplicates?: boolean
  }

  export type ComandaCreateWithoutUsuarioInput = {
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    mesa: MesaCreateNestedOneWithoutComandasInput
    pedidos?: PedidoCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoCreateNestedManyWithoutComandaInput
  }

  export type ComandaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    mesaId: number
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutComandaInput
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutComandaInput
  }

  export type ComandaCreateOrConnectWithoutUsuarioInput = {
    where: ComandaWhereUniqueInput
    create: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput>
  }

  export type ComandaCreateManyUsuarioInputEnvelope = {
    data: ComandaCreateManyUsuarioInput | ComandaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type LogStatusCreateWithoutUsuarioInput = {
    entidade: string
    entidadeId: number
    status: string
    criadoEm?: Date | string
  }

  export type LogStatusUncheckedCreateWithoutUsuarioInput = {
    id?: number
    entidade: string
    entidadeId: number
    status: string
    criadoEm?: Date | string
  }

  export type LogStatusCreateOrConnectWithoutUsuarioInput = {
    where: LogStatusWhereUniqueInput
    create: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput>
  }

  export type LogStatusCreateManyUsuarioInputEnvelope = {
    data: LogStatusCreateManyUsuarioInput | LogStatusCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutGarcomInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutGarcomInput, PedidoUncheckedUpdateWithoutGarcomInput>
    create: XOR<PedidoCreateWithoutGarcomInput, PedidoUncheckedCreateWithoutGarcomInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutGarcomInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutGarcomInput, PedidoUncheckedUpdateWithoutGarcomInput>
  }

  export type PedidoUpdateManyWithWhereWithoutGarcomInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutGarcomInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    id?: IntFilter<"Pedido"> | number
    comandaId?: IntFilter<"Pedido"> | number
    garcomId?: IntNullableFilter<"Pedido"> | number | null
    status?: StringFilter<"Pedido"> | string
    criadoEm?: DateTimeFilter<"Pedido"> | Date | string
  }

  export type ComandaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComandaWhereUniqueInput
    update: XOR<ComandaUpdateWithoutUsuarioInput, ComandaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComandaCreateWithoutUsuarioInput, ComandaUncheckedCreateWithoutUsuarioInput>
  }

  export type ComandaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComandaWhereUniqueInput
    data: XOR<ComandaUpdateWithoutUsuarioInput, ComandaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComandaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComandaScalarWhereInput
    data: XOR<ComandaUpdateManyMutationInput, ComandaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type LogStatusUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: LogStatusWhereUniqueInput
    update: XOR<LogStatusUpdateWithoutUsuarioInput, LogStatusUncheckedUpdateWithoutUsuarioInput>
    create: XOR<LogStatusCreateWithoutUsuarioInput, LogStatusUncheckedCreateWithoutUsuarioInput>
  }

  export type LogStatusUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: LogStatusWhereUniqueInput
    data: XOR<LogStatusUpdateWithoutUsuarioInput, LogStatusUncheckedUpdateWithoutUsuarioInput>
  }

  export type LogStatusUpdateManyWithWhereWithoutUsuarioInput = {
    where: LogStatusScalarWhereInput
    data: XOR<LogStatusUpdateManyMutationInput, LogStatusUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type LogStatusScalarWhereInput = {
    AND?: LogStatusScalarWhereInput | LogStatusScalarWhereInput[]
    OR?: LogStatusScalarWhereInput[]
    NOT?: LogStatusScalarWhereInput | LogStatusScalarWhereInput[]
    id?: IntFilter<"LogStatus"> | number
    entidade?: StringFilter<"LogStatus"> | string
    entidadeId?: IntFilter<"LogStatus"> | number
    status?: StringFilter<"LogStatus"> | string
    usuarioId?: IntNullableFilter<"LogStatus"> | number | null
    criadoEm?: DateTimeFilter<"LogStatus"> | Date | string
  }

  export type MesaCreateWithoutComandasInput = {
    numero: number
    status?: string
  }

  export type MesaUncheckedCreateWithoutComandasInput = {
    id?: number
    numero: number
    status?: string
  }

  export type MesaCreateOrConnectWithoutComandasInput = {
    where: MesaWhereUniqueInput
    create: XOR<MesaCreateWithoutComandasInput, MesaUncheckedCreateWithoutComandasInput>
  }

  export type UsuarioCreateWithoutComandasInput = {
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoCreateNestedManyWithoutGarcomInput
    logs?: LogStatusCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComandasInput = {
    id?: number
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutGarcomInput
    logs?: LogStatusUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComandasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComandasInput, UsuarioUncheckedCreateWithoutComandasInput>
  }

  export type PedidoCreateWithoutComandaInput = {
    status?: string
    criadoEm?: Date | string
    garcom?: UsuarioCreateNestedOneWithoutPedidosInput
    itens?: PedidoItemCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutComandaInput = {
    id?: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
    itens?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    ordensProducao?: OrdemProducaoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutComandaInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput>
  }

  export type PedidoCreateManyComandaInputEnvelope = {
    data: PedidoCreateManyComandaInput | PedidoCreateManyComandaInput[]
    skipDuplicates?: boolean
  }

  export type PagamentoCreateWithoutComandaInput = {
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
  }

  export type PagamentoUncheckedCreateWithoutComandaInput = {
    id?: number
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutComandaInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput>
  }

  export type PagamentoCreateManyComandaInputEnvelope = {
    data: PagamentoCreateManyComandaInput | PagamentoCreateManyComandaInput[]
    skipDuplicates?: boolean
  }

  export type MesaUpsertWithoutComandasInput = {
    update: XOR<MesaUpdateWithoutComandasInput, MesaUncheckedUpdateWithoutComandasInput>
    create: XOR<MesaCreateWithoutComandasInput, MesaUncheckedCreateWithoutComandasInput>
    where?: MesaWhereInput
  }

  export type MesaUpdateToOneWithWhereWithoutComandasInput = {
    where?: MesaWhereInput
    data: XOR<MesaUpdateWithoutComandasInput, MesaUncheckedUpdateWithoutComandasInput>
  }

  export type MesaUpdateWithoutComandasInput = {
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MesaUncheckedUpdateWithoutComandasInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUpsertWithoutComandasInput = {
    update: XOR<UsuarioUpdateWithoutComandasInput, UsuarioUncheckedUpdateWithoutComandasInput>
    create: XOR<UsuarioCreateWithoutComandasInput, UsuarioUncheckedCreateWithoutComandasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComandasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComandasInput, UsuarioUncheckedUpdateWithoutComandasInput>
  }

  export type UsuarioUpdateWithoutComandasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutGarcomNestedInput
    logs?: LogStatusUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComandasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutGarcomNestedInput
    logs?: LogStatusUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PedidoUpsertWithWhereUniqueWithoutComandaInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutComandaInput, PedidoUncheckedUpdateWithoutComandaInput>
    create: XOR<PedidoCreateWithoutComandaInput, PedidoUncheckedCreateWithoutComandaInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutComandaInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutComandaInput, PedidoUncheckedUpdateWithoutComandaInput>
  }

  export type PedidoUpdateManyWithWhereWithoutComandaInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutComandaInput>
  }

  export type PagamentoUpsertWithWhereUniqueWithoutComandaInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutComandaInput, PagamentoUncheckedUpdateWithoutComandaInput>
    create: XOR<PagamentoCreateWithoutComandaInput, PagamentoUncheckedCreateWithoutComandaInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutComandaInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutComandaInput, PagamentoUncheckedUpdateWithoutComandaInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutComandaInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutComandaInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    comandaId?: IntFilter<"Pagamento"> | number
    tipo?: StringFilter<"Pagamento"> | string
    valor?: FloatFilter<"Pagamento"> | number
    status?: StringFilter<"Pagamento"> | string
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
  }

  export type ComandaCreateWithoutPedidosInput = {
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    mesa: MesaCreateNestedOneWithoutComandasInput
    usuario?: UsuarioCreateNestedOneWithoutComandasInput
    pagamentos?: PagamentoCreateNestedManyWithoutComandaInput
  }

  export type ComandaUncheckedCreateWithoutPedidosInput = {
    id?: number
    mesaId: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutComandaInput
  }

  export type ComandaCreateOrConnectWithoutPedidosInput = {
    where: ComandaWhereUniqueInput
    create: XOR<ComandaCreateWithoutPedidosInput, ComandaUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioCreateWithoutPedidosInput = {
    nome: string
    login: string
    role: string
    senha: string
    comandas?: ComandaCreateNestedManyWithoutUsuarioInput
    logs?: LogStatusCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id?: number
    nome: string
    login: string
    role: string
    senha: string
    comandas?: ComandaUncheckedCreateNestedManyWithoutUsuarioInput
    logs?: LogStatusUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoItemCreateWithoutPedidoInput = {
    quantidade: number
    observacao?: string | null
    status?: string
    produto: ProdutoCreateNestedOneWithoutItensInput
    ordemItens?: OrdemItemCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemUncheckedCreateWithoutPedidoInput = {
    id?: number
    produtoId: number
    quantidade: number
    observacao?: string | null
    status?: string
    ordemItens?: OrdemItemUncheckedCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemCreateOrConnectWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemCreateManyPedidoInputEnvelope = {
    data: PedidoItemCreateManyPedidoInput | PedidoItemCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type OrdemProducaoCreateWithoutPedidoInput = {
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
    itens?: OrdemItemCreateNestedManyWithoutOrdemProducaoInput
  }

  export type OrdemProducaoUncheckedCreateWithoutPedidoInput = {
    id?: number
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
    itens?: OrdemItemUncheckedCreateNestedManyWithoutOrdemProducaoInput
  }

  export type OrdemProducaoCreateOrConnectWithoutPedidoInput = {
    where: OrdemProducaoWhereUniqueInput
    create: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput>
  }

  export type OrdemProducaoCreateManyPedidoInputEnvelope = {
    data: OrdemProducaoCreateManyPedidoInput | OrdemProducaoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type ComandaUpsertWithoutPedidosInput = {
    update: XOR<ComandaUpdateWithoutPedidosInput, ComandaUncheckedUpdateWithoutPedidosInput>
    create: XOR<ComandaCreateWithoutPedidosInput, ComandaUncheckedCreateWithoutPedidosInput>
    where?: ComandaWhereInput
  }

  export type ComandaUpdateToOneWithWhereWithoutPedidosInput = {
    where?: ComandaWhereInput
    data: XOR<ComandaUpdateWithoutPedidosInput, ComandaUncheckedUpdateWithoutPedidosInput>
  }

  export type ComandaUpdateWithoutPedidosInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mesa?: MesaUpdateOneRequiredWithoutComandasNestedInput
    usuario?: UsuarioUpdateOneWithoutComandasNestedInput
    pagamentos?: PagamentoUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagamentos?: PagamentoUncheckedUpdateManyWithoutComandaNestedInput
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPedidosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    comandas?: ComandaUpdateManyWithoutUsuarioNestedInput
    logs?: LogStatusUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    comandas?: ComandaUncheckedUpdateManyWithoutUsuarioNestedInput
    logs?: LogStatusUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutPedidoInput>
  }

  export type PedidoItemScalarWhereInput = {
    AND?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    OR?: PedidoItemScalarWhereInput[]
    NOT?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    id?: IntFilter<"PedidoItem"> | number
    pedidoId?: IntFilter<"PedidoItem"> | number
    produtoId?: IntFilter<"PedidoItem"> | number
    quantidade?: IntFilter<"PedidoItem"> | number
    observacao?: StringNullableFilter<"PedidoItem"> | string | null
    status?: StringFilter<"PedidoItem"> | string
  }

  export type OrdemProducaoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: OrdemProducaoWhereUniqueInput
    update: XOR<OrdemProducaoUpdateWithoutPedidoInput, OrdemProducaoUncheckedUpdateWithoutPedidoInput>
    create: XOR<OrdemProducaoCreateWithoutPedidoInput, OrdemProducaoUncheckedCreateWithoutPedidoInput>
  }

  export type OrdemProducaoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: OrdemProducaoWhereUniqueInput
    data: XOR<OrdemProducaoUpdateWithoutPedidoInput, OrdemProducaoUncheckedUpdateWithoutPedidoInput>
  }

  export type OrdemProducaoUpdateManyWithWhereWithoutPedidoInput = {
    where: OrdemProducaoScalarWhereInput
    data: XOR<OrdemProducaoUpdateManyMutationInput, OrdemProducaoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type OrdemProducaoScalarWhereInput = {
    AND?: OrdemProducaoScalarWhereInput | OrdemProducaoScalarWhereInput[]
    OR?: OrdemProducaoScalarWhereInput[]
    NOT?: OrdemProducaoScalarWhereInput | OrdemProducaoScalarWhereInput[]
    id?: IntFilter<"OrdemProducao"> | number
    pedidoId?: IntFilter<"OrdemProducao"> | number
    setor?: StringFilter<"OrdemProducao"> | string
    status?: StringFilter<"OrdemProducao"> | string
    criadaEm?: DateTimeFilter<"OrdemProducao"> | Date | string
    finalizadaEm?: DateTimeNullableFilter<"OrdemProducao"> | Date | string | null
  }

  export type ProdutoCreateWithoutCategoriaInput = {
    nome: string
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
    itens?: PedidoItemCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nome: string
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
    itens?: PedidoItemUncheckedCreateNestedManyWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutCategoriaInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProdutoCreateManyCategoriaInputEnvelope = {
    data: ProdutoCreateManyCategoriaInput | ProdutoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type ProdutoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ProdutoWhereUniqueInput
    update: XOR<ProdutoUpdateWithoutCategoriaInput, ProdutoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProdutoCreateWithoutCategoriaInput, ProdutoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProdutoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ProdutoWhereUniqueInput
    data: XOR<ProdutoUpdateWithoutCategoriaInput, ProdutoUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProdutoUpdateManyWithWhereWithoutCategoriaInput = {
    where: ProdutoScalarWhereInput
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type ProdutoScalarWhereInput = {
    AND?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    OR?: ProdutoScalarWhereInput[]
    NOT?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    id?: IntFilter<"Produto"> | number
    nome?: StringFilter<"Produto"> | string
    categoriaId?: IntNullableFilter<"Produto"> | number | null
    preco?: FloatFilter<"Produto"> | number
    ativo?: BoolFilter<"Produto"> | boolean
    foto?: StringNullableFilter<"Produto"> | string | null
    tipoOpcao?: StringFilter<"Produto"> | string
    sabores?: StringNullableFilter<"Produto"> | string | null
    isDrink?: BoolFilter<"Produto"> | boolean
    isFood?: BoolFilter<"Produto"> | boolean
    permitirObservacao?: BoolFilter<"Produto"> | boolean
    permiteGeloLimao?: BoolFilter<"Produto"> | boolean
    favorito?: BoolFilter<"Produto"> | boolean
    ultimoUso?: DateTimeNullableFilter<"Produto"> | Date | string | null
    estoque?: IntNullableFilter<"Produto"> | number | null
    esgotado?: BoolFilter<"Produto"> | boolean
  }

  export type CategoriaCreateWithoutProdutosInput = {
    nome: string
    setor: string
  }

  export type CategoriaUncheckedCreateWithoutProdutosInput = {
    id?: number
    nome: string
    setor: string
  }

  export type CategoriaCreateOrConnectWithoutProdutosInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProdutosInput, CategoriaUncheckedCreateWithoutProdutosInput>
  }

  export type PedidoItemCreateWithoutProdutoInput = {
    quantidade: number
    observacao?: string | null
    status?: string
    pedido: PedidoCreateNestedOneWithoutItensInput
    ordemItens?: OrdemItemCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemUncheckedCreateWithoutProdutoInput = {
    id?: number
    pedidoId: number
    quantidade: number
    observacao?: string | null
    status?: string
    ordemItens?: OrdemItemUncheckedCreateNestedManyWithoutPedidoItemInput
  }

  export type PedidoItemCreateOrConnectWithoutProdutoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput>
  }

  export type PedidoItemCreateManyProdutoInputEnvelope = {
    data: PedidoItemCreateManyProdutoInput | PedidoItemCreateManyProdutoInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaUpsertWithoutProdutosInput = {
    update: XOR<CategoriaUpdateWithoutProdutosInput, CategoriaUncheckedUpdateWithoutProdutosInput>
    create: XOR<CategoriaCreateWithoutProdutosInput, CategoriaUncheckedCreateWithoutProdutosInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutProdutosInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutProdutosInput, CategoriaUncheckedUpdateWithoutProdutosInput>
  }

  export type CategoriaUpdateWithoutProdutosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateWithoutProdutosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    setor?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutProdutoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutProdutoInput, PedidoItemUncheckedUpdateWithoutProdutoInput>
    create: XOR<PedidoItemCreateWithoutProdutoInput, PedidoItemUncheckedCreateWithoutProdutoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutProdutoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutProdutoInput, PedidoItemUncheckedUpdateWithoutProdutoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutProdutoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutProdutoInput>
  }

  export type PedidoCreateWithoutItensInput = {
    status?: string
    criadoEm?: Date | string
    comanda: ComandaCreateNestedOneWithoutPedidosInput
    garcom?: UsuarioCreateNestedOneWithoutPedidosInput
    ordensProducao?: OrdemProducaoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutItensInput = {
    id?: number
    comandaId: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
    ordensProducao?: OrdemProducaoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutItensInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutItensInput, PedidoUncheckedCreateWithoutItensInput>
  }

  export type ProdutoCreateWithoutItensInput = {
    nome: string
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
    categoria?: CategoriaCreateNestedOneWithoutProdutosInput
  }

  export type ProdutoUncheckedCreateWithoutItensInput = {
    id?: number
    nome: string
    categoriaId?: number | null
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
  }

  export type ProdutoCreateOrConnectWithoutItensInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutItensInput, ProdutoUncheckedCreateWithoutItensInput>
  }

  export type OrdemItemCreateWithoutPedidoItemInput = {
    ordemProducao: OrdemProducaoCreateNestedOneWithoutItensInput
  }

  export type OrdemItemUncheckedCreateWithoutPedidoItemInput = {
    id?: number
    ordemProducaoId: number
  }

  export type OrdemItemCreateOrConnectWithoutPedidoItemInput = {
    where: OrdemItemWhereUniqueInput
    create: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput>
  }

  export type OrdemItemCreateManyPedidoItemInputEnvelope = {
    data: OrdemItemCreateManyPedidoItemInput | OrdemItemCreateManyPedidoItemInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithoutItensInput = {
    update: XOR<PedidoUpdateWithoutItensInput, PedidoUncheckedUpdateWithoutItensInput>
    create: XOR<PedidoCreateWithoutItensInput, PedidoUncheckedCreateWithoutItensInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutItensInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutItensInput, PedidoUncheckedUpdateWithoutItensInput>
  }

  export type PedidoUpdateWithoutItensInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comanda?: ComandaUpdateOneRequiredWithoutPedidosNestedInput
    garcom?: UsuarioUpdateOneWithoutPedidosNestedInput
    ordensProducao?: OrdemProducaoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    ordensProducao?: OrdemProducaoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProdutoUpsertWithoutItensInput = {
    update: XOR<ProdutoUpdateWithoutItensInput, ProdutoUncheckedUpdateWithoutItensInput>
    create: XOR<ProdutoCreateWithoutItensInput, ProdutoUncheckedCreateWithoutItensInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutItensInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutItensInput, ProdutoUncheckedUpdateWithoutItensInput>
  }

  export type ProdutoUpdateWithoutItensInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneWithoutProdutosNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    categoriaId?: NullableIntFieldUpdateOperationsInput | number | null
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrdemItemUpsertWithWhereUniqueWithoutPedidoItemInput = {
    where: OrdemItemWhereUniqueInput
    update: XOR<OrdemItemUpdateWithoutPedidoItemInput, OrdemItemUncheckedUpdateWithoutPedidoItemInput>
    create: XOR<OrdemItemCreateWithoutPedidoItemInput, OrdemItemUncheckedCreateWithoutPedidoItemInput>
  }

  export type OrdemItemUpdateWithWhereUniqueWithoutPedidoItemInput = {
    where: OrdemItemWhereUniqueInput
    data: XOR<OrdemItemUpdateWithoutPedidoItemInput, OrdemItemUncheckedUpdateWithoutPedidoItemInput>
  }

  export type OrdemItemUpdateManyWithWhereWithoutPedidoItemInput = {
    where: OrdemItemScalarWhereInput
    data: XOR<OrdemItemUpdateManyMutationInput, OrdemItemUncheckedUpdateManyWithoutPedidoItemInput>
  }

  export type OrdemItemScalarWhereInput = {
    AND?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
    OR?: OrdemItemScalarWhereInput[]
    NOT?: OrdemItemScalarWhereInput | OrdemItemScalarWhereInput[]
    id?: IntFilter<"OrdemItem"> | number
    ordemProducaoId?: IntFilter<"OrdemItem"> | number
    pedidoItemId?: IntFilter<"OrdemItem"> | number
  }

  export type PedidoCreateWithoutOrdensProducaoInput = {
    status?: string
    criadoEm?: Date | string
    comanda: ComandaCreateNestedOneWithoutPedidosInput
    garcom?: UsuarioCreateNestedOneWithoutPedidosInput
    itens?: PedidoItemCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutOrdensProducaoInput = {
    id?: number
    comandaId: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
    itens?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutOrdensProducaoInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutOrdensProducaoInput, PedidoUncheckedCreateWithoutOrdensProducaoInput>
  }

  export type OrdemItemCreateWithoutOrdemProducaoInput = {
    pedidoItem: PedidoItemCreateNestedOneWithoutOrdemItensInput
  }

  export type OrdemItemUncheckedCreateWithoutOrdemProducaoInput = {
    id?: number
    pedidoItemId: number
  }

  export type OrdemItemCreateOrConnectWithoutOrdemProducaoInput = {
    where: OrdemItemWhereUniqueInput
    create: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput>
  }

  export type OrdemItemCreateManyOrdemProducaoInputEnvelope = {
    data: OrdemItemCreateManyOrdemProducaoInput | OrdemItemCreateManyOrdemProducaoInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithoutOrdensProducaoInput = {
    update: XOR<PedidoUpdateWithoutOrdensProducaoInput, PedidoUncheckedUpdateWithoutOrdensProducaoInput>
    create: XOR<PedidoCreateWithoutOrdensProducaoInput, PedidoUncheckedCreateWithoutOrdensProducaoInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutOrdensProducaoInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutOrdensProducaoInput, PedidoUncheckedUpdateWithoutOrdensProducaoInput>
  }

  export type PedidoUpdateWithoutOrdensProducaoInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comanda?: ComandaUpdateOneRequiredWithoutPedidosNestedInput
    garcom?: UsuarioUpdateOneWithoutPedidosNestedInput
    itens?: PedidoItemUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutOrdensProducaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type OrdemItemUpsertWithWhereUniqueWithoutOrdemProducaoInput = {
    where: OrdemItemWhereUniqueInput
    update: XOR<OrdemItemUpdateWithoutOrdemProducaoInput, OrdemItemUncheckedUpdateWithoutOrdemProducaoInput>
    create: XOR<OrdemItemCreateWithoutOrdemProducaoInput, OrdemItemUncheckedCreateWithoutOrdemProducaoInput>
  }

  export type OrdemItemUpdateWithWhereUniqueWithoutOrdemProducaoInput = {
    where: OrdemItemWhereUniqueInput
    data: XOR<OrdemItemUpdateWithoutOrdemProducaoInput, OrdemItemUncheckedUpdateWithoutOrdemProducaoInput>
  }

  export type OrdemItemUpdateManyWithWhereWithoutOrdemProducaoInput = {
    where: OrdemItemScalarWhereInput
    data: XOR<OrdemItemUpdateManyMutationInput, OrdemItemUncheckedUpdateManyWithoutOrdemProducaoInput>
  }

  export type OrdemProducaoCreateWithoutItensInput = {
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
    pedido: PedidoCreateNestedOneWithoutOrdensProducaoInput
  }

  export type OrdemProducaoUncheckedCreateWithoutItensInput = {
    id?: number
    pedidoId: number
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
  }

  export type OrdemProducaoCreateOrConnectWithoutItensInput = {
    where: OrdemProducaoWhereUniqueInput
    create: XOR<OrdemProducaoCreateWithoutItensInput, OrdemProducaoUncheckedCreateWithoutItensInput>
  }

  export type PedidoItemCreateWithoutOrdemItensInput = {
    quantidade: number
    observacao?: string | null
    status?: string
    pedido: PedidoCreateNestedOneWithoutItensInput
    produto: ProdutoCreateNestedOneWithoutItensInput
  }

  export type PedidoItemUncheckedCreateWithoutOrdemItensInput = {
    id?: number
    pedidoId: number
    produtoId: number
    quantidade: number
    observacao?: string | null
    status?: string
  }

  export type PedidoItemCreateOrConnectWithoutOrdemItensInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutOrdemItensInput, PedidoItemUncheckedCreateWithoutOrdemItensInput>
  }

  export type OrdemProducaoUpsertWithoutItensInput = {
    update: XOR<OrdemProducaoUpdateWithoutItensInput, OrdemProducaoUncheckedUpdateWithoutItensInput>
    create: XOR<OrdemProducaoCreateWithoutItensInput, OrdemProducaoUncheckedCreateWithoutItensInput>
    where?: OrdemProducaoWhereInput
  }

  export type OrdemProducaoUpdateToOneWithWhereWithoutItensInput = {
    where?: OrdemProducaoWhereInput
    data: XOR<OrdemProducaoUpdateWithoutItensInput, OrdemProducaoUncheckedUpdateWithoutItensInput>
  }

  export type OrdemProducaoUpdateWithoutItensInput = {
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedido?: PedidoUpdateOneRequiredWithoutOrdensProducaoNestedInput
  }

  export type OrdemProducaoUncheckedUpdateWithoutItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PedidoItemUpsertWithoutOrdemItensInput = {
    update: XOR<PedidoItemUpdateWithoutOrdemItensInput, PedidoItemUncheckedUpdateWithoutOrdemItensInput>
    create: XOR<PedidoItemCreateWithoutOrdemItensInput, PedidoItemUncheckedCreateWithoutOrdemItensInput>
    where?: PedidoItemWhereInput
  }

  export type PedidoItemUpdateToOneWithWhereWithoutOrdemItensInput = {
    where?: PedidoItemWhereInput
    data: XOR<PedidoItemUpdateWithoutOrdemItensInput, PedidoItemUncheckedUpdateWithoutOrdemItensInput>
  }

  export type PedidoItemUpdateWithoutOrdemItensInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    pedido?: PedidoUpdateOneRequiredWithoutItensNestedInput
    produto?: ProdutoUpdateOneRequiredWithoutItensNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutOrdemItensInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ComandaCreateWithoutPagamentosInput = {
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    mesa: MesaCreateNestedOneWithoutComandasInput
    usuario?: UsuarioCreateNestedOneWithoutComandasInput
    pedidos?: PedidoCreateNestedManyWithoutComandaInput
  }

  export type ComandaUncheckedCreateWithoutPagamentosInput = {
    id?: number
    mesaId: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutComandaInput
  }

  export type ComandaCreateOrConnectWithoutPagamentosInput = {
    where: ComandaWhereUniqueInput
    create: XOR<ComandaCreateWithoutPagamentosInput, ComandaUncheckedCreateWithoutPagamentosInput>
  }

  export type ComandaUpsertWithoutPagamentosInput = {
    update: XOR<ComandaUpdateWithoutPagamentosInput, ComandaUncheckedUpdateWithoutPagamentosInput>
    create: XOR<ComandaCreateWithoutPagamentosInput, ComandaUncheckedCreateWithoutPagamentosInput>
    where?: ComandaWhereInput
  }

  export type ComandaUpdateToOneWithWhereWithoutPagamentosInput = {
    where?: ComandaWhereInput
    data: XOR<ComandaUpdateWithoutPagamentosInput, ComandaUncheckedUpdateWithoutPagamentosInput>
  }

  export type ComandaUpdateWithoutPagamentosInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mesa?: MesaUpdateOneRequiredWithoutComandasNestedInput
    usuario?: UsuarioUpdateOneWithoutComandasNestedInput
    pedidos?: PedidoUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateWithoutPagamentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutComandaNestedInput
  }

  export type UsuarioCreateWithoutLogsInput = {
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoCreateNestedManyWithoutGarcomInput
    comandas?: ComandaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutLogsInput = {
    id?: number
    nome: string
    login: string
    role: string
    senha: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutGarcomInput
    comandas?: ComandaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutLogsInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutLogsInput, UsuarioUncheckedCreateWithoutLogsInput>
  }

  export type UsuarioUpsertWithoutLogsInput = {
    update: XOR<UsuarioUpdateWithoutLogsInput, UsuarioUncheckedUpdateWithoutLogsInput>
    create: XOR<UsuarioCreateWithoutLogsInput, UsuarioUncheckedCreateWithoutLogsInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutLogsInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutLogsInput, UsuarioUncheckedUpdateWithoutLogsInput>
  }

  export type UsuarioUpdateWithoutLogsInput = {
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutGarcomNestedInput
    comandas?: ComandaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutGarcomNestedInput
    comandas?: ComandaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ComandaCreateManyMesaInput = {
    id?: number
    usuarioId?: number | null
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
  }

  export type ComandaUpdateWithoutMesaInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: UsuarioUpdateOneWithoutComandasNestedInput
    pedidos?: PedidoUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateWithoutMesaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUncheckedUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateManyWithoutMesaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PedidoCreateManyGarcomInput = {
    id?: number
    comandaId: number
    status?: string
    criadoEm?: Date | string
  }

  export type ComandaCreateManyUsuarioInput = {
    id?: number
    mesaId: number
    status?: string
    total?: number
    abertaEm?: Date | string
    fechadaEm?: Date | string | null
  }

  export type LogStatusCreateManyUsuarioInput = {
    id?: number
    entidade: string
    entidadeId: number
    status: string
    criadoEm?: Date | string
  }

  export type PedidoUpdateWithoutGarcomInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    comanda?: ComandaUpdateOneRequiredWithoutPedidosNestedInput
    itens?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutGarcomInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutGarcomInput = {
    id?: IntFieldUpdateOperationsInput | number
    comandaId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComandaUpdateWithoutUsuarioInput = {
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mesa?: MesaUpdateOneRequiredWithoutComandasNestedInput
    pedidos?: PedidoUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutComandaNestedInput
    pagamentos?: PagamentoUncheckedUpdateManyWithoutComandaNestedInput
  }

  export type ComandaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mesaId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    abertaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    fechadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogStatusUpdateWithoutUsuarioInput = {
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogStatusUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogStatusUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidade?: StringFieldUpdateOperationsInput | string
    entidadeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyComandaInput = {
    id?: number
    garcomId?: number | null
    status?: string
    criadoEm?: Date | string
  }

  export type PagamentoCreateManyComandaInput = {
    id?: number
    tipo: string
    valor: number
    status: string
    criadoEm?: Date | string
  }

  export type PedidoUpdateWithoutComandaInput = {
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    garcom?: UsuarioUpdateOneWithoutPedidosNestedInput
    itens?: PedidoItemUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutComandaInput = {
    id?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    ordensProducao?: OrdemProducaoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutComandaInput = {
    id?: IntFieldUpdateOperationsInput | number
    garcomId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUpdateWithoutComandaInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateWithoutComandaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyWithoutComandaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoItemCreateManyPedidoInput = {
    id?: number
    produtoId: number
    quantidade: number
    observacao?: string | null
    status?: string
  }

  export type OrdemProducaoCreateManyPedidoInput = {
    id?: number
    setor: string
    status?: string
    criadaEm?: Date | string
    finalizadaEm?: Date | string | null
  }

  export type PedidoItemUpdateWithoutPedidoInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    produto?: ProdutoUpdateOneRequiredWithoutItensNestedInput
    ordemItens?: OrdemItemUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordemItens?: OrdemItemUncheckedUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    produtoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OrdemProducaoUpdateWithoutPedidoInput = {
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itens?: OrdemItemUpdateManyWithoutOrdemProducaoNestedInput
  }

  export type OrdemProducaoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itens?: OrdemItemUncheckedUpdateManyWithoutOrdemProducaoNestedInput
  }

  export type OrdemProducaoUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    setor?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    criadaEm?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizadaEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProdutoCreateManyCategoriaInput = {
    id?: number
    nome: string
    preco: number
    ativo?: boolean
    foto?: string | null
    tipoOpcao?: string
    sabores?: string | null
    isDrink?: boolean
    isFood?: boolean
    permitirObservacao?: boolean
    permiteGeloLimao?: boolean
    favorito?: boolean
    ultimoUso?: Date | string | null
    estoque?: number | null
    esgotado?: boolean
  }

  export type ProdutoUpdateWithoutCategoriaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
    itens?: PedidoItemUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
    itens?: PedidoItemUncheckedUpdateManyWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    tipoOpcao?: StringFieldUpdateOperationsInput | string
    sabores?: NullableStringFieldUpdateOperationsInput | string | null
    isDrink?: BoolFieldUpdateOperationsInput | boolean
    isFood?: BoolFieldUpdateOperationsInput | boolean
    permitirObservacao?: BoolFieldUpdateOperationsInput | boolean
    permiteGeloLimao?: BoolFieldUpdateOperationsInput | boolean
    favorito?: BoolFieldUpdateOperationsInput | boolean
    ultimoUso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estoque?: NullableIntFieldUpdateOperationsInput | number | null
    esgotado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoItemCreateManyProdutoInput = {
    id?: number
    pedidoId: number
    quantidade: number
    observacao?: string | null
    status?: string
  }

  export type PedidoItemUpdateWithoutProdutoInput = {
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    pedido?: PedidoUpdateOneRequiredWithoutItensNestedInput
    ordemItens?: OrdemItemUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ordemItens?: OrdemItemUncheckedUpdateManyWithoutPedidoItemNestedInput
  }

  export type PedidoItemUncheckedUpdateManyWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type OrdemItemCreateManyPedidoItemInput = {
    id?: number
    ordemProducaoId: number
  }

  export type OrdemItemUpdateWithoutPedidoItemInput = {
    ordemProducao?: OrdemProducaoUpdateOneRequiredWithoutItensNestedInput
  }

  export type OrdemItemUncheckedUpdateWithoutPedidoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordemProducaoId?: IntFieldUpdateOperationsInput | number
  }

  export type OrdemItemUncheckedUpdateManyWithoutPedidoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    ordemProducaoId?: IntFieldUpdateOperationsInput | number
  }

  export type OrdemItemCreateManyOrdemProducaoInput = {
    id?: number
    pedidoItemId: number
  }

  export type OrdemItemUpdateWithoutOrdemProducaoInput = {
    pedidoItem?: PedidoItemUpdateOneRequiredWithoutOrdemItensNestedInput
  }

  export type OrdemItemUncheckedUpdateWithoutOrdemProducaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoItemId?: IntFieldUpdateOperationsInput | number
  }

  export type OrdemItemUncheckedUpdateManyWithoutOrdemProducaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoItemId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MesaCountOutputTypeDefaultArgs instead
     */
    export type MesaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MesaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComandaCountOutputTypeDefaultArgs instead
     */
    export type ComandaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComandaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoCountOutputTypeDefaultArgs instead
     */
    export type PedidoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoCountOutputTypeDefaultArgs instead
     */
    export type ProdutoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoItemCountOutputTypeDefaultArgs instead
     */
    export type PedidoItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdemProducaoCountOutputTypeDefaultArgs instead
     */
    export type OrdemProducaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdemProducaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MesaDefaultArgs instead
     */
    export type MesaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MesaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComandaDefaultArgs instead
     */
    export type ComandaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComandaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDefaultArgs instead
     */
    export type PedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaDefaultArgs instead
     */
    export type CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProdutoDefaultArgs instead
     */
    export type ProdutoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProdutoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoItemDefaultArgs instead
     */
    export type PedidoItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdemProducaoDefaultArgs instead
     */
    export type OrdemProducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdemProducaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdemItemDefaultArgs instead
     */
    export type OrdemItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdemItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagamentoDefaultArgs instead
     */
    export type PagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogStatusDefaultArgs instead
     */
    export type LogStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrinterConfigDefaultArgs instead
     */
    export type PrinterConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrinterConfigDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}